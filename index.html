<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pitch Accent Graph</title>
<link rel="stylesheet" href="accent_colors.css">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: system-ui, -apple-system, sans-serif;
  background: #1a1a2e;
  color: #e0e0e0;
  min-height: 100vh;
  padding: 48px 64px;
  max-width: 900px;
  margin: 0 auto;
}
h1 { font-size: 1.3rem; font-weight: 600; margin-bottom: 16px; color: #fff; }
textarea {
  width: 100%;
  min-height: 160px;
  background: #16213e;
  color: #e0e0e0;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 12px;
  font-family: "Hiragino Mincho ProN", "Yu Mincho", "Noto Serif CJK JP", serif;
  font-size: 16px;
  line-height: 1.6;
  resize: vertical;
}
textarea:focus { outline: none; border-color: #5a7; }
#output {
  margin-top: 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.graph-row {
  background: #FFFAF0;
  border-radius: 6px;
  padding: 8px 12px;
  display: inline-block;
}
.dl-btn {
  background: none;
  border: 1px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  padding: 2px 8px;
  font-size: 13px;
  color: #999;
  margin-top: 4px;
}
.dl-btn:hover { border-color: #888; color: #333; }
details { margin-top: 16px; color: #999; font-size: 13px; }
summary { cursor: pointer; margin-bottom: 8px; }
details table { border-collapse: collapse; margin-top: 4px; }
details td, details th { padding: 3px 12px 3px 0; text-align: left; }

/* Sentence display */
.sentence-row {
  font-family: "Hiragino Mincho ProN", "Yu Mincho", "Noto Serif CJK JP", serif;
  font-size: 22px;
  line-height: 1.6;
  margin-bottom: 2px;
}
.sentence-row ruby { ruby-align: center; }
.sentence-row rt { font-size: 0.55em; }
</style>
</head>
<body>
<h1>Pitch Accent Graph</h1>
<textarea id="input" spellcheck="false" placeholder="Enter pitch accent notation...">がっこう:0
おおもの:2
にほんご:0 の: じしょ:1
食[た]べ 物[もの]:3
ひとり:2+</textarea>
<div id="output"></div>

<details>
<summary>Syntax Reference</summary>
<table>
<tr><th>Syntax</th><th>Meaning</th></tr>
<tr><td><code>word:0</code></td><td>Heiban (flat)</td></tr>
<tr><td><code>word:1</code></td><td>Atamadaka (accent on 1st mora)</td></tr>
<tr><td><code>word:2</code></td><td>Nakadaka (accent on 2nd mora)</td></tr>
<tr><td><code>word:N</code></td><td>Accent on Nth mora (odaka if N = mora count)</td></tr>
<tr><td><code>大物[おおもの]:2</code></td><td>Kanji with furigana</td></tr>
<tr><td><code>食[た]べ 物[もの]:3</code></td><td>Multi-kanji word (fragments merge into :)</td></tr>
<tr><td><code>の:</code></td><td>Particle (colon, no accent number)</td></tr>
<tr><td><code>word:0 particle:</code></td><td>Word followed by particle</td></tr>
<tr><td><code>word:1 ; word:0</code></td><td>Tape connector (dotted line)</td></tr>
<tr><td><code>word:1 | word:0</code></td><td>Break (no connector)</td></tr>
<tr><td><code>word:1 , word:0</code></td><td>Comma break</td></tr>
<tr><td><code>word:1+</code></td><td>Ghost/trailing particle</td></tr>
<tr><td><code>ぐらい:pa</code></td><td>Particle with atamadaka</td></tr>
<tr><td><code>*き*み</code></td><td>Devoiced mora (prefix *)</td></tr>
<tr><td><code>\は:p</code></td><td>Literal kana (no は→ワ conversion)</td></tr>
<tr><td><code>word:k2</code></td><td>Kifuku accent</td></tr>
<tr><td><code>A:hlll</code></td><td>Keihan notation</td></tr>
</table>
</details>

<script src="config.js"></script>
<script src="kana.js"></script>
<script src="parse.js"></script>
<script src="section.js"></script>
<script src="graph.js"></script>
<script src="sentence.js"></script>
<script>
function makeSequences(expr) {
  expr = normalizeForParsing(expr);
  let sentences = splitToSentences(expr);
  sentences = sentences.map(detachGhostParticle);
  let bySection = sentences.map(splitToSections);
  bySection = bySection.map(mergeFragments);
  bySection = splitMultiplePitchNotations(bySection);
  let sequences = bySection.map(parseSections);
  sequences = sequences.map(buildHighLow);
  return sequences;
}

function makeGraphs(sequences) {
  return sequences.map(makeGraph).filter(Boolean);
}

const inputEl = document.getElementById('input');
const outputEl = document.getElementById('output');

function update() {
  const expr = inputEl.value.trim();
  if (!expr) { outputEl.innerHTML = ''; return; }
  try {
    const sequences = makeSequences(expr);
    outputEl.innerHTML = sequences.map(seq => {
      const graph = makeGraph(seq);
      if (!graph) return '';
      const sentence = makeColoredSentence(seq);
      return `<div class="graph-row"><div class="sentence-row">${sentence}</div>${graph}<br><button class="dl-btn" onclick="downloadPng(this)">Save PNG</button> <button class="dl-btn" onclick="downloadSvg(this)">Save SVG</button></div>`;
    }).join('');
  } catch (e) {
    outputEl.innerHTML = `<div style="color:#e55">${e.message}</div>`;
  }
}

const saved = localStorage.getItem('pitch-input');
if (saved != null) inputEl.value = saved;

inputEl.addEventListener('input', () => {
  localStorage.setItem('pitch-input', inputEl.value);
  update();
});
update();

function getGraphName(row) {
  return row.querySelector('.sentence-row')?.textContent.trim().slice(0, 20) || 'pitch';
}

function cloneWithStyles(svg) {
  const clone = svg.cloneNode(true);
  const origEls = svg.querySelectorAll('*');
  const cloneEls = clone.querySelectorAll('*');
  const props = ['fill', 'stroke', 'stroke-width', 'stroke-dasharray', 'font-family', 'font-size', 'display'];
  for (let i = 0; i < origEls.length; i++) {
    const cs = getComputedStyle(origEls[i]);
    for (const p of props) {
      const v = cs.getPropertyValue(p);
      if (v) cloneEls[i].style.setProperty(p, v);
    }
  }
  return clone;
}

function triggerDownload(blob, filename) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

function downloadSvg(btn) {
  const row = btn.closest('.graph-row');
  const svg = row.querySelector('svg');
  if (!svg) return;
  const clone = cloneWithStyles(svg);
  clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  const data = new XMLSerializer().serializeToString(clone);
  triggerDownload(new Blob([data], { type: 'image/svg+xml;charset=utf-8' }), getGraphName(row) + '.svg');
}

function downloadPng(btn) {
  const row = btn.closest('.graph-row');
  const svg = row.querySelector('svg');
  if (!svg) return;
  const clone = cloneWithStyles(svg);

  const vb = clone.getAttribute('viewBox').split(' ').map(Number);
  const scale = 3;
  const w = vb[2] * scale, h = vb[3] * scale;
  clone.removeAttribute('height');
  clone.setAttribute('width', w);
  clone.setAttribute('height', h);

  const data = new XMLSerializer().serializeToString(clone);
  const blob = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const img = new Image();
  img.onload = () => {
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    c.getContext('2d').drawImage(img, 0, 0, w, h);
    URL.revokeObjectURL(url);
    c.toBlob(pngBlob => {
      triggerDownload(pngBlob, getGraphName(row) + '.png');
    });
  };
  img.src = url;
}
</script>
</body>
</html>
