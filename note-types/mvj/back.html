<div class="card-inner">
  <div class="back">
      {{FrontSide}}
  
      {{#Definition Audio}}
      <div id="def-audio-container" style="display:none">{{Definition Audio}}</div>
      {{/Definition Audio}}
  
      <script>
      (function() {
          // Clear stale state from previous card (Anki reuses the webview)
          window.__defAudioRawHtml = null;
          window.__defAudioNativeContainer = null;
          window.__defAudioEls = [];
          window.__monoUnlocked = false;
          window.__autoPlayDefAudio = null;
          window.__playLockedDefAudio = null;
  
          var container = document.getElementById('def-audio-container');
          if (!container) return;

          var _defAudioOff = getComputedStyle(document.documentElement)
              .getPropertyValue('--definition-audio').trim() === 'off';

          // Tagged definition audio: defer to _renderBack()
          if (container.innerHTML.indexOf('def-type="') !== -1) {
              if (container.textContent.indexOf('[audio:') !== -1) {
                  window.__defAudioRawHtml = container.innerHTML;
                  container.remove();
              } else {
                  window.__defAudioNativeContainer = container;
              }
              return;
          }
  
          // Check for [audio:] custom tags vs [sound:] native tags
          if (container.textContent.indexOf('[audio:') !== -1) {
              // [audio:] — JS playback path
              var result = window.__extractAudio(container);
              var filenames = result.filenames;
              container.remove();
              if (!filenames.length || _defAudioOff) return;
  
              var SVG = window.__audioSVG;
              var audioRow = document.querySelector('.audio-row');
              var audios = [];
              var btns = [];
  
              var item = document.createElement('div');
              item.className = 'audio-item bi';
              item.setAttribute('data-audio', 'def');
  
              for (var i = 0; i < filenames.length; i++) {
                  var audio = document.createElement('audio');
                  audio.preload = 'auto';
                  audio.src = filenames[i];
                  document.body.appendChild(audio);
                  audios.push(audio);
                  window.__defAudioEls.push(audio);
  
                  var btn = document.createElement('a');
                  btn.className = 'replay-button';
                  btn.href = '#';
                  btn.innerHTML = SVG;
                  item.appendChild(btn);
                  btns.push(btn);
              }
  
              var label = document.createElement('span');
              label.className = 'audio-label';
              label.textContent = 'Definition';
              item.appendChild(label);
              if (audioRow) audioRow.appendChild(item);
  
              var animateBtn = window.__animateBtn;
  
              function playSingle(idx) {
                  if (window.matchMedia('(hover: none)').matches) {
                      window.__stopAllAudio();
                      animateBtn(btns[idx]);
                      window.__playMobile(audios[idx].src, btns[idx]);
                  } else {
                      window.__stopAllAudio(audios[idx]);
                      audios[idx].currentTime = 0;
                      window.__safePlay(audios[idx]);
                      animateBtn(btns[idx]);
                      window.__startPlaying(audios[idx], btns[idx]);
                  }
              }
  
              function playAll() {
                  var mob = window.matchMedia('(hover: none)').matches;
                  if (mob) {
                      window.__stopAllAudio();
                      var gen = window.__webAudioGen;
                      var idx = 0;
                      (function next() {
                          if (idx >= audios.length || gen !== window.__webAudioGen) return;
                          var cur = idx++;
                          animateBtn(btns[cur]);
                          window.__playMobile(audios[cur].src, btns[cur])
                              .then(function() { if (gen === window.__webAudioGen) next(); })
                              ['catch'](function() { if (gen === window.__webAudioGen) next(); });
                      })();
                  } else {
                      window.__stopAllAudio(audios[0]);
                      var idx = 0;
                      function playNext() {
                          if (idx >= audios.length) return;
                          var cur = idx++;
                          audios[cur].currentTime = 0;
                          audios[cur].onended = audios[cur].onerror = playNext;
                          window.__safePlay(audios[cur]);
                          animateBtn(btns[cur]);
                          window.__startPlaying(audios[cur], btns[cur]);
                      }
                      playNext();
                  }
              }
  
              for (var j = 0; j < btns.length; j++) {
                  (function(idx) {
                      window.__onTap(btns[idx], function() { playSingle(idx); }, function() { window.__stopAllAudio(); });
                  })(j);
              }
  
              window.__playLockedDefAudio = playAll;
              window.__autoPlayDefAudio = playAll;
  
              var toggle = document.getElementById('jp-toggle');
              if (toggle) {
                  toggle.addEventListener('change', function() {
                      if (toggle.checked && !window.__monoUnlocked) playAll();
                  });
              }
          } else {
              // [sound:] — adopt native elements
              if (_defAudioOff) { container.remove(); return; }
              var nativeEls = Array.from(container.querySelectorAll('.replay-button, audio'));
              var buttons = window.__adoptNativeAudio(nativeEls);
              container.remove();
              if (!buttons.length) return;
  
              var audioRow = document.querySelector('.audio-row');
              var item = document.createElement('div');
              item.className = 'audio-item bi';
              item.setAttribute('data-audio', 'def');
              for (var i = 0; i < buttons.length; i++) {
                  item.appendChild(buttons[i]);
              }
              var label = document.createElement('span');
              label.className = 'audio-label';
              label.textContent = 'Definition';
              item.appendChild(label);
              if (audioRow) audioRow.appendChild(item);
  
              window.__playLockedDefAudio = function() {
                  buttons[0].click();
                  window.__animateBtn(buttons[0]);
              };
              window.__autoPlayDefAudio = window.__playLockedDefAudio;

              var toggle = document.getElementById('jp-toggle');
              if (toggle) {
                  toggle.addEventListener('change', function() {
                      if (toggle.checked && !window.__monoUnlocked) buttons[0].click();
                  });
              }
          }
      })();
      </script>
      <div class="answer">
          <div class="word-column">
              <h1 class="target-word" style="--d:0" id="target-word"></h1>
              <div class="pitch-graph" style="--d:50" id="pitch-graph"></div>
              {{#Image}}
              <div class="image-wrap" style="--d:135">{{Image}}</div>
              {{/Image}}
          </div>
          <p class="sentence" style="--d:95" id="sentence"></p>
          <div class="audio-row-bottom" id="audio-row-bottom" style="--d:150"></div>
          <div class="divider" style="--d:160"></div>
          <p class="def" style="--d:170" id="def-bilingual"></p>
          <div class="jp-def-section" style="--d:225" id="jp-def-section">
              <input type="checkbox" id="jp-toggle" class="jp-def-input">
              <label for="jp-toggle" class="jp-def-toggle" onclick="">Monolingual</label>
              <div class="jp-def-wrap">
                  <p class="jp-def" id="def-monolingual"></p>
              </div>
          </div>
      </div>
  </div>
  </div>
  
  <div id="raw-definition" style="display:none">{{Definition}}</div>
  
  <script>
  (function() {
  // ── config.js ──
  const config = {
    no_text: false, size_unit: 25, font_size: 24, text_dx: -12,
    x_step: 50, circle_radius: 5.25, devoiced_circle_width: 1.5,
    devoiced_circle_radius: 17, devoiced_stroke_disarray: "2 3",
    devoiced_rectangle_padding: 5, stroke_width: 2.5, graph_height: 40,
    graph_visible_height: 100, graph_horizontal_padding: 6,
    graph_font: "'Noto Serif JP', 'Hiragino Mincho ProN', 'Yu Mincho', serif",
    convert_reading: 'katakana', stroke_dasharray: '4',
  };
  
  // ── kana.js ──
  const _hiragana = [
    'が','ぎ','ぐ','げ','ご','ざ','じ','ず','ぜ','ぞ','だ','ぢ','づ','で','ど',
    'ば','び','ぶ','べ','ぼ','ぱ','ぴ','ぷ','ぺ','ぽ','あ','い','う','え','お',
    'か','き','く','け','こ','さ','し','す','せ','そ','た','ち','つ','て','と',
    'な','に','ぬ','ね','の','は','ひ','ふ','へ','ほ','ま','み','む','め','も',
    'や','ゆ','よ','ら','り','る','れ','ろ','わ','を','ん','ぁ','ぃ','ぅ','ぇ','ぉ',
    'ゃ','ゅ','ょ','っ',
  ];
  const _katakana = [
    'ガ','ギ','グ','ゲ','ゴ','ザ','ジ','ズ','ゼ','ゾ','ダ','ヂ','ヅ','デ','ド',
    'バ','ビ','ブ','ベ','ボ','パ','ピ','プ','ペ','ポ','ア','イ','ウ','エ','オ',
    'カ','キ','ク','ケ','コ','サ','シ','ス','セ','ソ','タ','チ','ツ','テ','ト',
    'ナ','ニ','ヌ','ネ','ノ','ハ','ヒ','フ','ヘ','ホ','マ','ミ','ム','メ','モ',
    'ヤ','ユ','ヨ','ラ','リ','ル','レ','ロ','ワ','ヲ','ン','ァ','ィ','ゥ','ェ','ォ',
    'ャ','ュ','ョ','ッ',
  ];
  const k2h = {}, h2k = {};
  _katakana.forEach((k, i) => { k2h[k] = _hiragana[i]; h2k[_hiragana[i]] = k; });
  
  function toHiragana(s) { return [...s].map(c => k2h[c] || c).join(''); }
  function toKatakana(s) { return [...s].map(c => h2k[c] || c).join(''); }
  
  const EQ_SOUNDS_HIRA = {
    'ぢ':'じ','づ':'ず','を':'お','れい':'れー','めい':'めー','べい':'べー',
    'けい':'けー','ぐう':'ぐー','ごう':'ごー','ずう':'ずー','づう':'ずー',
    'づー':'ずー','ぞう':'ぞー','どう':'どー','どお':'どー','ぶう':'ぶー',
    'ぼう':'ぼー','ぷう':'ぷー','ぽう':'ぽー','うう':'うー','おう':'おー',
    'おお':'おー','くう':'くー','こう':'こー','すう':'すー','そう':'そー',
    'つう':'つー','とう':'とー','とお':'とー','こお':'こー','ぬう':'ぬー',
    'のう':'のー','ふう':'ふー','ほう':'ほー','ほお':'ほー','むう':'むー',
    'もう':'もー','よう':'よー','るう':'るー','ろう':'ろー','ぅう':'ぅー',
    'ぉう':'ぉー','ょう':'ょー','ゆう':'ゆー','いい':'いー','ちい':'ちー',
    'せい':'せー','じい':'じー','かあ':'かー','ゅう':'ゅー','ぜい':'ぜー',
    'きい':'きー','しい':'しー','にい':'にー','ひい':'ひー','みい':'みー',
    'りい':'りー','ぎい':'ぎー','びい':'びー','ぴい':'ぴー',
    'えい':'えー','てい':'てー','ねい':'ねー','へい':'へー',
    'でい':'でー','げい':'げー','ぺい':'ぺー',
    'つづ':'つず','じゃあ':'じゃー',
  };
  const EQUIVALENT_SOUNDS = {...EQ_SOUNDS_HIRA};
  for (const [k, v] of Object.entries(EQ_SOUNDS_HIRA)) {
    EQUIVALENT_SOUNDS[toKatakana(k)] = toKatakana(v);
  }
  
  function unifyRepr(reading) {
    for (const [k, v] of Object.entries(EQUIVALENT_SOUNDS)) {
      reading = reading.replaceAll(k, v);
    }
    return reading;
  }
  function literalPronunciation(text) { return toKatakana(unifyRepr(text)); }
  
  // ── parse.js ──
  const GHOST_PARTICLE = '-';
  const DEVOICED_PREFIX = '*';
  const LITERAL_PREFIX = '\\';
  const HIGH_PREFIX = '^';
  const SENT_HIDDEN = ['|', GHOST_PARTICLE];
  const PITCH_BREAKS = [...SENT_HIDDEN, ',', '、'];
  
  function normalizeForParsing(expr) {
    expr = expr.replace(/<br\s*\/?>/gi, ' . ');
    expr = expr.replace(/<[^<>]+>/gi, '');
    expr = escapeBrackets(expr);
    // Protect digit-only brackets from furigana regex (not valid readings)
    expr = expr.replace(/\[(\d+)\]/g, '\u2045$1\u2046');
    // Strip split furigana before | gets treated as a separator
    expr = expr.replace(/\[([^\]]*)\|([^\]]*)\]/g, '[$2]');
    expr = expr.replace(/\s*[\/／]\s*/g, ' ; ');
    expr = expr.replace(/([。!?！？])/g, ' $1 .');
    expr = expr.replace(/([「」|、､])/g, ' $1 ');
    expr = expr.replace(/([^ ]), /g, ' $1 , ');
    return expr;
  }
  
  function splitToSentences(expr) {
    return expr.split(/[.\n]+/).map(s => s.trim()).filter(Boolean);
  }
  
  function splitToSections(sentence) {
    return sentence.split(/[\t\s\u3000]+/).filter(Boolean);
  }
  
  function detachGhostParticle(text) {
    return text.replace(/(-+)[\s\n.]*$/, ' $1');
  }
  
  function furiganaToReading(word) {
    return word.split(' ').map(part => {
      part = part.replace(/\[([^\]]*)\|([^\]]*)\]/g, '[$2]');
      part = part.replace(/([\*\^]+)([^\[\]\*\^]*)\[/g, '$2[$1');
      return part.replace(/([^\[\]]*\[|])/g, '');
    }).join('');
  }
  
  function filterKana(reading) {
    return reading.replace(/[^\u3040-\u309F\u30A0-\u30FF\*\-\\\^]/g, '');
  }
  
  function kanaToMoraes(kana) {
    return kana.match(/(?:[\*\\\^]{1,3})?.[ァィゥェォャュョぁぃぅぇぉゃゅょ]?/g) || [];
  }
  
  function splitToMoras(reading) {
    const kana = filterKana(reading);
    const raw = kanaToMoraes(kana);
    return raw.map(m => {
      let devoiced = false, literal = false, high = false;
      while (m.length > 0) {
        if (m.startsWith(DEVOICED_PREFIX)) { devoiced = true; m = m.slice(1); }
        else if (m.startsWith(LITERAL_PREFIX)) { literal = true; m = m.slice(1); }
        else if (m.startsWith(HIGH_PREFIX)) { high = true; m = m.slice(1); }
        else break;
      }
      return { text: m, devoiced, literal, high };
    });
  }
  
  function splitSection(raw) {
    const m = raw.match(/^([^:]+)(:)?(.*)$/);
    if (m) return { word: m[1], sep: m[2] || null, accent: m[3] || '' };
    return { word: raw, sep: null, accent: '' };
  }
  
  function splitAccent(raw) {
    if (!raw && raw !== '') raw = '';
    let m = raw.match(/^(p)?([a-zA-Z])?(~)?(\d)?(~)?$/);
    if (m) {
      return {
        is_particle: m[1] || null,
        role: m[2] || m[1] || null,
        allLow: !!(m[3] || m[5]),
        pitch: m[4] || null,
      };
    }
    m = raw.match(/^([a-zA-Z]{1,2}):([hlHL]+)$/);
    if (m) {
      return { role: m[1], levels: m[2], keihan: true };
    }
    return { role: null, pitch: null };
  }
  
  const SEPARATORS = [';', '|', ',', '、', '-', '「', '」'];
  
  function mergeFragments(sections) {
    const result = [];
    let pending = [];
    for (const raw of sections) {
      if (SEPARATORS.includes(raw)) {
        result.push(...pending);
        pending = [];
        result.push(raw);
        continue;
      }
      const { sep } = splitSection(raw);
      if (sep == null) {
        pending.push(raw);
      } else {
        if (pending.length) {
          const merged = [...pending, raw.replace(/:.*$/, '')].join(' ');
          const accent = raw.replace(/^[^:]*:/, '');
          result.push(merged + ':' + accent);
          pending = [];
        } else {
          result.push(raw);
        }
      }
    }
    result.push(...pending);
    return result;
  }
  
  function splitMultiplePitchNotations(sequences) {
    const result = [];
    for (const seq of sequences) {
      const alternatives = seq.map(raw => {
        const sec = splitSection(raw);
        if (sec.sep && sec.accent.includes(',')) {
          return sec.accent.split(',').map(a => `${sec.word}:${a.trim()}`);
        }
        return [raw];
      });
      let combos = [[]];
      for (const alts of alternatives) {
        combos = combos.flatMap(prev => alts.map(a => [...prev, a]));
      }
      result.push(...combos);
    }
    return result;
  }
  
  // ── section.js ──
  const RoleFromValue = {
    'h':'heiban','a':'atamadaka','n':'nakadaka','o':'odaka','k':'kifuku',
    'b':'black','w':'white','s':'setsubigo','e':'empty','p':'particle',
    'H':'keihan_heiban','A':'keihan_atamadaka','N':'keihan_nakadaka',
    'L':'keihan_low_heiban','M':'keihan_low_nakadaka','O':'keihan_low_odaka',
    'K':'keihan_kifuku',
  };
  
  function isEmptyParticle(word) { return /^[|,、]$/.test(word); }
  
  function determineRoleKeihan(rawRole) {
    const val = String(rawRole || 'H');
    return RoleFromValue[val.toUpperCase()] || RoleFromValue[val.toLowerCase()] || 'keihan_heiban';
  }
  
  function determineLevelsKeihan(levels, moraes) {
    const arr = [...String(levels).toLowerCase()];
    while (arr.length < moraes.length) arr.push(arr[arr.length - 1]);
    return arr;
  }
  
  function guessRoleFromPitchNum(moraes, pitchN) {
    if (pitchN == null) return 'heiban';
    const n = parseInt(pitchN);
    if (n === 0) return 'heiban';
    if (n === 1) return 'atamadaka';
    if (n === moraes.length) return 'odaka';
    if (n < moraes.length) return 'nakadaka';
    return 'heiban';
  }
  
  function determineRoleTokyo(sd) {
    if (isEmptyParticle(sd.word)) return 'empty';
    if (sd.moraes.length === 0 && sd.sep == null) return 'empty';
    if (sd.sep == null) return 'particle';
    if (sd.moraes.length === 0) {
      if (sd.accent.role != null) return RoleFromValue[sd.accent.role.toLowerCase()] || 'heiban';
      if (sd.accent.pitch != null) return guessRoleFromPitchNum(sd.moraes, sd.accent.pitch);
      return 'empty';
    }
    if (sd.accent.role == null && sd.accent.pitch == null) return 'particle';
    if (sd.accent.role == null) return guessRoleFromPitchNum(sd.moraes, sd.accent.pitch);
    return RoleFromValue[sd.accent.role.toLowerCase()] || 'heiban';
  }
  
  function determinePitchTokyo(sd) {
    if (sd.accent.allLow) return -1;
    if (sd.sep && sd.accent.pitch != null) return parseInt(sd.accent.pitch);
    const role = sd.accent.role;
    if (role === 'heiban' || role === 'setsubigo') return 0;
    if (role === 'atamadaka') return 1;
    if (role === 'nakadaka' || role === 'kifuku') return 2;
    if (role === 'odaka') return sd.moraes.length;
    if (role === 'particle') return null;
    if (role === 'empty') return -1;
    return 0;
  }
  
  function adjustKana(text) {
    if (config.convert_reading === 'katakana') {
      const literals = [];
      text = text.replace(/\\(\*?)(.)/g, (_, star, ch) => {
        literals.push(ch);
        return star + '\uE000';
      });
      const devoiced = new Set();
      let clean = '';
      for (const ch of text) {
        if (ch === DEVOICED_PREFIX) devoiced.add(clean.length);
        else clean += ch;
      }
      clean = literalPronunciation(clean);
      text = '';
      for (let i = 0; i < clean.length; i++) {
        if (devoiced.has(i)) text += DEVOICED_PREFIX;
        text += clean[i];
      }
      let j = 0;
      text = text.replace(/\uE000/g, () => LITERAL_PREFIX + toKatakana(literals[j++]));
      return text;
    }
    if (config.convert_reading === 'hiragana') return toHiragana(text);
    return text;
  }
  
  function prepareMoras(word) {
    let reading = furiganaToReading(word);
    reading = adjustKana(reading);
    return splitToMoras(reading);
  }
  
  class Section {
    constructor(rawSection) {
      this.raw = rawSection;
      this._d = splitSection(rawSection);
      this._d.moraes = prepareMoras(this._d.word || '');
      this._d.accent = splitAccent(this._d.accent || '');
      this._initAccent();
    }
  
    _initAccent() {
      const a = this._d.accent;
      if (a.keihan) {
        a.role = determineRoleKeihan(a.role);
        a.levels = determineLevelsKeihan(a.levels, this._d.moraes);
      } else {
        a.keihan = false;
        a.role = determineRoleTokyo(this._d);
        a.pitch = determinePitchTokyo(this._d);
      }
    }
  
    get isTape() { return this.raw === ';'; }
    get isParticle() { return !!this._d.accent.is_particle; }
  
    get word() { return this._d.word.replaceAll(DEVOICED_PREFIX, '').replaceAll(LITERAL_PREFIX, '').replaceAll(HIGH_PREFIX, ''); }
  
    get moraes() {
      const m = this._d.moraes;
      if ((this.role === 'particle' || this.isParticle) && m.length === 1 && !m[0].literal) {
        if (m[0].text === 'ハ') return [{ text: 'ワ', devoiced: m[0].devoiced, literal: false, high: m[0].high }];
        if (m[0].text === 'ヘ') return [{ text: 'エ', devoiced: m[0].devoiced, literal: false, high: m[0].high }];
      }
      return m;
    }
  
    get role() { return this._d.accent.role; }
  
    get classname() {
      if (this.isParticle) {
        return [...new Set(['particle', this.role])].join(' ');
      }
      return this.role;
    }
  
    get pitch() { return this._d.accent.pitch; }
    set pitch(v) { this._d.accent.pitch = v; }
  
    get levels() { return this._d.accent.levels; }
    set levels(v) { this._d.accent.levels = v; }
  
    get isKeihan() { return !!this._d.accent.keihan; }
  }
  
  const H = 'h', L = 'l';
  
  function buildLevelsTokyo(section, lastLow) {
    if (section.pitch == null) section.pitch = lastLow ? -1 : -2;
    if (section.pitch === -1) return section.moraes.map(() => L);
    if (section.pitch === -2) return section.moraes.map(() => H);
    if (section.pitch === 1) return [H, ...section.moraes.slice(1).map(() => L)];
  
    return section.moraes.map((_, i) => {
      if (i === 0) return lastLow ? L : H;
      return (i < section.pitch || section.pitch === 0) ? H : L;
    });
  }
  
  function calcLastWordEndedLow(section, lastLow) {
    if (section.role === 'empty' && !PITCH_BREAKS.includes(section.word)) return lastLow;
    if (section.pitch === 1) return true;
    if (section.pitch === 0 || section.pitch === -2) return false;
    return section.moraes.length >= section.pitch;
  }
  
  function buildHighLow(sequence) {
    let lastLow = true;
    for (const section of sequence) {
      if (section.isKeihan) {
        lastLow = section.levels[section.levels.length - 1] === L;
      } else {
        section.levels = buildLevelsTokyo(section, lastLow);
        for (let i = 0; i < section.moraes.length; i++) {
          if (section.moraes[i].high) section.levels[i] = H;
        }
        lastLow = calcLastWordEndedLow(section, lastLow);
      }
    }
    return sequence;
  }
  
  function parseSections(seq) { return seq.map(s => new Section(s)); }
  
  function filterEmptyMoraes(sequence) {
    return sequence.filter(s =>
      s.moraes.length || PITCH_BREAKS.includes(s.word) || s.isTape
    );
  }
  
  // ── graph.js ──
  class Line {
    constructor() { this.x1 = this.y1 = this.x2 = this.y2 = null; this._tape = false; }
    start(x, y, tape = false) { this.x1 = x; this.y1 = y; this._tape = tape; return this; }
    end(x, y) { this.x2 = x; this.y2 = y; return this; }
    get isUnfinished() { return this.x1 != null && this.y1 != null; }
    get isCompleted() { return this.x2 != null && this.y2 != null; }
  
    adjustToRadius(r) {
      const tan = config.graph_height / config.x_step;
      const denom = Math.sqrt(1 + tan * tan);
      const sin = tan / denom, cos = 1 / denom;
      const oy = r * sin, ox = r * cos;
      if (this.y1 === this.y2) { this.x1 += r; this.x2 -= r; }
      else if (this.y1 > this.y2) { this.x1 += ox; this.y1 -= oy; this.x2 -= ox; this.y2 += oy; }
      else { this.x1 += ox; this.y1 += oy; this.x2 -= ox; this.y2 -= oy; }
      return this;
    }
  
    draw() {
      let s = `<line stroke="black" stroke-width="${config.stroke_width}" x1="${this.x1.toFixed(3)}" y1="${this.y1.toFixed(3)}" x2="${this.x2.toFixed(3)}" y2="${this.y2.toFixed(3)}" />`;
      if (this._tape) s = s.replace('<line', `<line stroke-dasharray="${config.stroke_dasharray}"`);
      return s;
    }
  }
  
  class Path {
    constructor() { this.lines = []; }
    get last() { return this.lines[this.lines.length - 1]; }
    startAt(x, y) { this.lines.push(new Line().start(x, y)); }
    goTo(x, y) { this.last.end(x, y); }
    push(x, y) {
      if (this.lines.length === 0) { this.startAt(x, y); }
      else if (this.last.isCompleted) { this.startAt(this.last.x2, this.last.y2); this.goTo(x, y); }
      else { this.goTo(x, y); }
    }
    draw() {
      return this.lines
        .filter(l => l.isCompleted)
        .map(l => { l.adjustToRadius(config.circle_radius); return l.draw(); })
        .join('');
    }
  }
  
  function shouldConnect(section, prev) {
    if (prev.isTape) return true;
    if (section.role === 'empty' || prev.role === 'empty') return false;
    return true;
  }
  
  function makeCircle(x, y) {
    return `<circle fill="black" stroke="black" stroke-width="${config.stroke_width}" cx="${x}" cy="${y}" r="${config.circle_radius}"></circle>`;
  }
  
  function makeDevoicedCircle(mora, x, y) {
    if (mora.text.length === 1) {
      const cx = x + config.font_size / 2 + config.text_dx;
      const cy = y + config.text_dx + Math.ceil(config.stroke_width);
      return `<circle class="devoiced" cx="${cx}" cy="${cy}" stroke-width="${config.devoiced_circle_width}" r="${config.devoiced_circle_radius}" stroke-dasharray="${config.devoiced_stroke_disarray}" />`;
    }
    const fs = config.font_size, r = config.devoiced_circle_radius;
    const ry = y - config.font_size - Math.floor(config.stroke_width);
    const pad = config.devoiced_rectangle_padding;
    return `<rect class="devoiced" x="${x - fs - pad}" y="${ry}" width="${fs * 2 + pad * 2}" height="${r * 2}" rx="${r}" stroke-width="${config.devoiced_circle_width}" stroke-dasharray="${config.devoiced_stroke_disarray}" />`;
  }
  
  function makeGroup(elements, cls) { return `<g class="${cls}">${elements.join('')}</g>`; }
  function makeSvg(contents, w, h, vh) {
    return `<svg style="font-family: ${config.graph_font}" viewBox="0 0 ${w} ${h}" height="${vh}px" xmlns="http://www.w3.org/2000/svg">${contents}</svg>`;
  }
  function makeText(mora, x, y, dx) {
    const cls = mora.devoiced ? ' class="devoiced"' : '';
    return `<text${cls} font-size="${config.font_size}px" fill="black" x="${x}" y="${y}" dx="${dx}">${mora.text}</text>`;
  }
  
  function calcSvgWidth(sequence, step) {
    return sequence.reduce((sum, s) => sum + (s.role !== 'empty' ? s.moraes.length : 0), 0) * step
      + config.graph_horizontal_padding * 2;
  }
  
  function makeGraph(sequence) {
    sequence = filterEmptyMoraes(sequence);
    if (!sequence.length) return null;
  
    let xPos = config.size_unit + config.graph_horizontal_padding;
    let yPos = config.size_unit;
    const heightHigh = config.size_unit;
    const heightLow = heightHigh + config.graph_height;
    const xStep = config.x_step;
    const heightKana = heightLow + xStep;
  
    const circles = [], paths = [], text = [];
  
    for (let i = 0; i < sequence.length; i++) {
      const section = sequence[i];
      if (section.role === 'empty' || section.isTape) continue;
  
      const wordCircles = [], textMoraes = [];
      const path = new Path();
      const connector = new Line();
  
      if (i > 0 && shouldConnect(section, sequence[i - 1])) {
        connector.start(xPos - xStep, yPos, sequence[i - 1].isTape);
      }
  
      const moraes = section.moraes;
      for (let j = 0; j < moraes.length; j++) {
        const mora = moraes[j];
        let moraLevel;
        if (mora.text === 'っ' || mora.text === 'ッ') {
          moraLevel = (j === 1 && section.levels[j - 1] === L) ? section.levels[j - 1] : section.levels[j];
        } else {
          moraLevel = section.levels[j];
        }
        yPos = moraLevel === H ? heightHigh : heightLow;
        wordCircles.push(makeCircle(xPos, yPos));
        path.push(xPos, yPos);
  
        if (j === 0 && connector.isUnfinished) {
          connector.end(xPos, yPos);
        }
  
        if (mora.text !== GHOST_PARTICLE) {
          if (mora.devoiced) {
            textMoraes.push(makeDevoicedCircle(mora, xPos, heightKana));
          }
          textMoraes.push(makeText(mora, xPos, heightKana, config.text_dx * mora.text.length));
        }
  
        xPos += xStep;
      }
  
      circles.push(makeGroup(wordCircles, section.classname));
      paths.push(makeGroup([path.draw()], section.classname));
      text.push(makeGroup(textMoraes, section.classname));
  
      if (connector.isCompleted) {
        paths.push(makeGroup([connector.adjustToRadius(config.circle_radius).draw()], 'connector'));
      }
    }
  
    const content = [makeGroup(paths, 'paths'), makeGroup(circles, 'circles')];
    const svgWidth = calcSvgWidth(sequence, xStep);
    const svgHeightText = heightKana + config.size_unit;
    const svgHeightNoText = heightLow + config.size_unit;
  
    let svgHeight, visibleHeight;
    if (config.no_text) {
      svgHeight = svgHeightNoText;
      visibleHeight = Math.round((svgHeightNoText / svgHeightText) * config.graph_visible_height);
    } else {
      svgHeight = svgHeightText;
      visibleHeight = config.graph_visible_height;
      content.push(makeGroup(text, 'text'));
    }
  
    return makeSvg(content.join(''), svgWidth, svgHeight, visibleHeight);
  }
  
  // ── sentence.js ──
  function wordToRuby(word) {
    word = word.replaceAll(DEVOICED_PREFIX, '');
    word = word.replaceAll(LITERAL_PREFIX, '');
    return word.split(' ').map(textToRuby).join('');
  }
  
  function makeColoredSentence(sequence) {
    const spans = [];
    for (const section of sequence) {
      if (SENT_HIDDEN.includes(section.word) || /^-+$/.test(section.word) || section.isTape) continue;
      spans.push(`<span class="${section.classname}">${wordToRuby(section.word)}</span>`);
    }
    return spans.join('');
  }
  
  // ── makeSequences glue ──
  function makeSequences(expr) {
    expr = normalizeForParsing(expr);
    let sentences = splitToSentences(expr);
    sentences = sentences.map(detachGhostParticle);
    let bySection = sentences.map(splitToSections);
    bySection = bySection.map(mergeFragments);
    bySection = splitMultiplePitchNotations(bySection);
    let sequences = bySection.map(parseSections);
    sequences = sequences.map(buildHighLow);
    return sequences;
  }
  
  // ── parseDefinitions ──
  function parseDefinitions(html) {
    const defs = {};
    var CMT = '<' + '!--';
    var END = '--' + '>';
    const re = new RegExp(CMT + '\\s*def-type="(\\w+)"[\\s\\S]*?' + END + '([\\s\\S]*?)' + CMT + '\\s*def-end\\s*' + END, 'g');
    let m;
    while ((m = re.exec(html)) !== null) {
      defs[m[1]] = m[2].trim();
    }
    return defs;
  }
  
  function applyDefModeFilter(defs, mode) {
      if (mode === 'bilingual') {
          delete defs.monolingual;
          delete defs.LOCKED_monolingual;
      } else if (mode === 'monolingual') {
          delete defs.bilingual;
          if (defs.LOCKED_monolingual) {
              defs.monolingual = defs.LOCKED_monolingual;
              delete defs.LOCKED_monolingual;
          }
      } else if (mode === 'unlocked') {
          if (defs.LOCKED_monolingual) {
              defs.monolingual = defs.LOCKED_monolingual;
              delete defs.LOCKED_monolingual;
          }
      }
  }

  // ── Render (deferred for Anki front→back transitions) ──
  function _renderBack() {
    if (!document.querySelector('.answer')) return setTimeout(_renderBack, 10);

    var wordEl = document.getElementById('raw-word');
    var wordRaw = wordEl ? wordEl.innerHTML.trim() : '';
    var sentEl = document.getElementById('raw-sentence');
    var sentRaw = sentEl ? sentEl.textContent.trim() : '';
    var defHtml = document.getElementById('raw-definition').innerHTML;
  
    var targetEl = document.getElementById('target-word');
    var graphEl = document.getElementById('pitch-graph');
    var sentEl = document.getElementById('sentence');
    var defEl = document.getElementById('def-bilingual');
    var jpDefSection = document.getElementById('jp-def-section');
    var jpDefEl = document.getElementById('def-monolingual');

    // ── Settings ──
    var _rootStyle = getComputedStyle(document.documentElement);
    var wordOn = _rootStyle.getPropertyValue('--word-text').trim() !== 'off';
    var sentOn = _rootStyle.getPropertyValue('--sentence-text').trim() !== 'off';
    var graphOn = _rootStyle.getPropertyValue('--pitch-graph').trim() !== 'off';

    var defText = _rootStyle.getPropertyValue('--definition-text').trim() !== 'off';
    var defAudio = _rootStyle.getPropertyValue('--definition-audio').trim() !== 'off';
    var defMode = _rootStyle.getPropertyValue('--definition-mode').trim() || 'all';

    var rawWPC = _rootStyle.getPropertyValue('--word-pitch-color').trim();
    var wordPitchColor = (rawWPC === 'front') ? 'front' : (rawWPC === 'off') ? 'off' : 'back';
    var rawSPC = _rootStyle.getPropertyValue('--sentence-pitch-color').trim();
    var sentPitchColor = (rawSPC === 'front') ? 'front' : (rawSPC === 'off') ? 'off' : 'back';
    var rawDPC = _rootStyle.getPropertyValue('--definition-pitch-color').trim();
    var defPitchColor = (rawDPC === 'front') ? 'front' : (rawDPC === 'off') ? 'off' : 'back';

    var wordFurigana = _rootStyle.getPropertyValue('--word-furigana').trim() || 'back';
    var sentFurigana = _rootStyle.getPropertyValue('--sentence-furigana').trim() || 'back';
    var defFurigana = _rootStyle.getPropertyValue('--definition-furigana').trim() || 'back';

    var wordSide = _rootStyle.getPropertyValue('--word-text').trim() || 'back';
    var sentSide = _rootStyle.getPropertyValue('--sentence-text').trim() || 'back';
    var imageSide = _rootStyle.getPropertyValue('--image').trim() || 'back';
    var answerEl = document.querySelector('.answer');
    var wordIsOnFront = (wordSide === 'front');
    var sentIsOnFront = (sentSide === 'front');
    var isTategaki = document.documentElement.classList.contains('tategaki');

    // Word → target word + pitch graph
    var wordSeqs = wordRaw ? makeSequences(wordRaw) : [];

    if (!wordOn) {
      targetEl.setAttribute('data-show', 'off');
    } else if (wordRaw) {
      var wordTarget = wordIsOnFront
          ? document.getElementById('front-word')
          : targetEl;

      if (wordSeqs.length > 0) {
        wordTarget.innerHTML = makeColoredSentence(wordSeqs[0]);
        if (wordRaw.indexOf(':') === -1) wordTarget.classList.add('no-accent');
        if (wordPitchColor === 'off') wordTarget.classList.add('no-pitch-color');
        if (wordFurigana === 'off') wordTarget.classList.add('furigana-off');
      }

      if (wordIsOnFront) {
        targetEl.setAttribute('data-show', 'off');
        answerEl.setAttribute('data-word-zone', 'front');
      }
    } else {
      if (wordIsOnFront) {
        var frontWordEl = document.getElementById('front-word');
        if (frontWordEl) frontWordEl.setAttribute('data-side', 'back');
      }
    }

    // Word text-play on back
    if (wordOn && wordRaw) {
      var wordTextPlayEl = wordIsOnFront ? document.getElementById('front-word') : targetEl;
      if (wordTextPlayEl && wordTextPlayEl.innerHTML) {
        window.__linkTextPlay(wordTextPlayEl, 'word', {
          play: function() {
            var item = document.querySelector('.audio-item[data-audio="word"]');
            window.__playItemAudios(item);
          },
          getBtn: function() {
            return document.querySelector('.audio-item[data-audio="word"] .replay-button');
          },
          getAllBtns: function() {
            return Array.from(document.querySelectorAll('.audio-item[data-audio="word"] .replay-button'));
          }
        });
      }
    }

    if (graphOn && wordSeqs.length > 0 && wordRaw.indexOf(':') !== -1) {
      var svgs = [];
      for (var s = 0; s < wordSeqs.length; s++) {
        var svg = makeGraph(wordSeqs[s]);
        if (svg) svgs.push(svg);
      }
      if (svgs.length > 0) {
        graphEl.innerHTML = svgs.join('');
      } else {
        graphEl.setAttribute('data-state', 'empty');
      }
    } else {
      graphEl.setAttribute('data-state', 'empty');
    }
  
    // Sentence → colored sentence
    if (!sentOn) {
      sentEl.setAttribute('data-show', 'off');
    } else if (sentRaw) {
      var sentSeqs = makeSequences(sentRaw);
      var sentTarget = (sentIsOnFront && !isTategaki)
          ? document.getElementById('front-sentence')
          : sentEl;

      if (sentSeqs.length > 0) {
        var hasAccent = sentSeqs[0].some(function(s) {
          return s.role !== 'particle' && s.role !== 'empty' && !s.isParticle;
        });
        if (!hasAccent) sentTarget.classList.add('no-accent');
        if (sentPitchColor === 'off') sentTarget.classList.add('no-pitch-color');
        if (sentFurigana === 'off') sentTarget.classList.add('furigana-off');
        sentTarget.innerHTML = makeColoredSentence(sentSeqs[0]);
      }

      if (sentIsOnFront && !isTategaki) {
        sentEl.setAttribute('data-show', 'off');
      }
      if (sentIsOnFront && isTategaki) {
        // Copy colored sentence to front-content so it wraps with word/image
        var frontSentEl = document.getElementById('front-sentence');
        if (frontSentEl && sentEl.innerHTML) {
          frontSentEl.innerHTML = sentEl.innerHTML;
          if (sentEl.classList.contains('no-accent')) frontSentEl.classList.add('no-accent');
          if (sentEl.classList.contains('no-pitch-color')) frontSentEl.classList.add('no-pitch-color');
          if (sentFurigana !== 'back') frontSentEl.classList.add('furigana-' + sentFurigana);
          if (sentPitchColor === 'front') frontSentEl.classList.add('pitch-color-front');
        }
        sentEl.setAttribute('data-show', 'off');
      }
    } else if (sentIsOnFront) {
      var frontSentEl = document.getElementById('front-sentence');
      if (frontSentEl) frontSentEl.setAttribute('data-side', 'back');
    }

    // Sentence text-play on back
    if (sentOn && sentRaw) {
      var sentTextPlayEl = sentIsOnFront
        ? document.getElementById('front-sentence')
        : sentEl;
      if (sentTextPlayEl && sentTextPlayEl.innerHTML
          && sentTextPlayEl.getAttribute('data-show') !== 'off') {
        window.__linkTextPlay(sentTextPlayEl, 'sentence', {
          play: function() {
            var item = document.querySelector('.audio-item[data-audio="sentence"]');
            window.__playItemAudios(item);
          },
          getBtn: function() {
            return document.querySelector('.audio-item[data-audio="sentence"] .replay-button');
          },
          getAllBtns: function() {
            return Array.from(document.querySelectorAll('.audio-item[data-audio="sentence"] .replay-button'));
          }
        });
      }
    }

    // Image → hide answer copy when image is on front or off
    if (imageSide === 'front') {
      var frontImageEl = document.getElementById('front-image');
      var rawImageEl = document.getElementById('raw-image');
      if (frontImageEl && rawImageEl && rawImageEl.innerHTML.trim()) {
        frontImageEl.innerHTML = rawImageEl.innerHTML;
      } else if (frontImageEl) {
        frontImageEl.setAttribute('data-side', 'back');
      }
      var answerImage = document.querySelector('.answer .image-wrap');
      if (answerImage) answerImage.setAttribute('data-show', 'off');
    } else if (imageSide === 'off') {
      var answerImage = document.querySelector('.answer .image-wrap');
      if (answerImage) answerImage.setAttribute('data-show', 'off');
    }
    if (window.__checkImageFit) window.__checkImageFit();

    // Definition → bilingual + monolingual
    function colorizeText(raw, el) {
      if (!raw) return '';
      if (el && raw.indexOf(':') === -1) el.classList.add('no-accent');
      var lines = raw.split(/<br\s*\/?>/gi);
      var colored = lines.map(function(line) {
        var seqs = makeSequences(line);
        if (seqs.length === 0) return line;
        return seqs.map(makeColoredSentence).join('');
      });
      return colored.join('<br>');
    }
    var defs = parseDefinitions(defHtml);
    // Plain definition without comment markers → use --definition-default
    if (!Object.keys(defs).length && defHtml.trim()) {
      var defDefault = _rootStyle.getPropertyValue('--definition-default').trim() || 'monolingual';
      defs[defDefault] = defHtml.trim();
    }
    applyDefModeFilter(defs, defMode);
    var monoKey = defs.monolingual ? 'monolingual' : (defs.LOCKED_monolingual ? 'LOCKED_monolingual' : null);
    var hasBi = !!defs.bilingual;
    var hasMono = !!monoKey;
  
    var answerEl = document.querySelector('.answer');

    if (hasBi && !hasMono) {
      defEl.innerHTML = defs.bilingual;
      answerEl.setAttribute('data-def-layout', 'bi-only');
    } else if (hasMono && !hasBi) {
      defEl.innerHTML = colorizeText(defs[monoKey], defEl) || defs[monoKey];
      defEl.setAttribute('data-font', 'jp');
      answerEl.setAttribute('data-def-layout', 'mono-only');
      window.__monoUnlocked = true;
    } else if (hasBi && hasMono) {
      if (defs.monolingual) {
        defEl.innerHTML = colorizeText(defs.monolingual, defEl) || defs.monolingual;
        defEl.setAttribute('data-font', 'jp');
        jpDefEl.innerHTML = defs.bilingual;
        jpDefEl.className = 'def';
        var toggleLabel = document.querySelector('.jp-def-toggle');
        if (toggleLabel) toggleLabel.textContent = 'Bilingual';
        answerEl.setAttribute('data-def-layout', 'dual-mono');
        window.__monoUnlocked = true;
      } else {
        defEl.innerHTML = defs.bilingual;
        jpDefEl.innerHTML = colorizeText(defs.LOCKED_monolingual, jpDefEl) || defs.LOCKED_monolingual;
        answerEl.setAttribute('data-def-layout', 'dual-bi');
      }
    } else {
      answerEl.setAttribute('data-def-layout', 'none');
    }

    if (!defText) {
      answerEl.setAttribute('data-def-text', 'off');
    }

    if (defPitchColor === 'off') {
      defEl.classList.add('no-pitch-color');
      jpDefEl.classList.add('no-pitch-color');
    }
    if (defFurigana === 'off') {
      defEl.classList.add('furigana-off');
      jpDefEl.classList.add('furigana-off');
    }

    // ── Tagged definition audio: native [sound:] elements ──
    if (window.__defAudioNativeContainer && defAudio) {
      var nativeContainer = window.__defAudioNativeContainer;
      window.__defAudioNativeContainer = null;

      var nodes = Array.from(nativeContainer.childNodes);
      var nativeGroups = {};
      var curType = null;
      for (var ni = 0; ni < nodes.length; ni++) {
        var node = nodes[ni];
        if (node.nodeType === 8) {
          var typeMatch = node.textContent.match(/def-type="(\w+)"/);
          if (typeMatch) {
            curType = typeMatch[1];
            nativeGroups[curType] = [];
          } else if (node.textContent.indexOf('def-end') !== -1) {
            curType = null;
          }
        } else if (curType && node.nodeType === 1) {
          nativeGroups[curType].push(node);
        }
      }
      applyDefModeFilter(nativeGroups, defMode);

      var biBtns = nativeGroups.bilingual ? window.__adoptNativeAudio(nativeGroups.bilingual) : [];
      var nativeMonoKey = nativeGroups.monolingual ? 'monolingual' : (nativeGroups.LOCKED_monolingual ? 'LOCKED_monolingual' : null);
      var monoBtns = nativeMonoKey ? window.__adoptNativeAudio(nativeGroups[nativeMonoKey]) : [];
      var hasBiBtns = biBtns.length > 0;
      var hasMonoBtns = monoBtns.length > 0;
  
      if (hasBiBtns || hasMonoBtns) {
        var audioRow = document.querySelector('.audio-row');
  
        if (hasBiBtns && hasMonoBtns) {
          var makeNativeDefItem = function(label, btns, defRole, defLang) {
            var item = document.createElement('div');
            item.className = 'audio-item bi';
            item.setAttribute('data-audio', 'def');
            item.setAttribute('data-def-role', defRole);
            item.setAttribute('data-def-lang', defLang);
            for (var bk = 0; bk < btns.length; bk++) {
              item.appendChild(btns[bk]);
            }
            var lbl = document.createElement('span');
            lbl.className = 'audio-label';
            lbl.textContent = label;
            item.appendChild(lbl);
            if (audioRow) audioRow.appendChild(item);
          };
  
          makeNativeDefItem('Bi-Def', biBtns,
            window.__monoUnlocked ? 'secondary' : 'primary', 'bi');
          makeNativeDefItem('Mono-Def', monoBtns,
            window.__monoUnlocked ? 'primary' : 'secondary', 'mono');
  
          var primaryBtns = window.__monoUnlocked ? monoBtns : biBtns;
          var secondaryBtns = window.__monoUnlocked ? biBtns : monoBtns;
  
          window.__playLockedDefAudio = function() {
            primaryBtns[0].click();
            window.__animateBtn(primaryBtns[0]);
          };
          window.__autoPlayDefAudio = window.__playLockedDefAudio;

          var defToggle = document.getElementById('jp-toggle');
          if (defToggle) {
            defToggle.addEventListener('change', function() {
              if (defToggle.checked) secondaryBtns[0].click();
            });
          }
        } else {
          var singleBtns = hasBiBtns ? biBtns : monoBtns;
          var singleType = hasBiBtns ? 'bilingual' : 'monolingual';
  
          var singleItem = document.createElement('div');
          singleItem.className = 'audio-item bi';
          singleItem.setAttribute('data-audio', 'def');
          for (var si = 0; si < singleBtns.length; si++) {
            singleItem.appendChild(singleBtns[si]);
          }
          var singleLabel = document.createElement('span');
          singleLabel.className = 'audio-label';
          singleLabel.textContent = 'Definition';
          singleItem.appendChild(singleLabel);
          if (audioRow) audioRow.appendChild(singleItem);
  
          window.__playLockedDefAudio = function() {
            singleBtns[0].click();
            window.__animateBtn(singleBtns[0]);
          };
  
          var singleShown = (singleType === 'bilingual' && !window.__monoUnlocked) ||
                             (singleType === 'monolingual' && !!window.__monoUnlocked);
          if (singleShown) {
            window.__autoPlayDefAudio = window.__playLockedDefAudio;
          } else {
            var defToggle = document.getElementById('jp-toggle');
            if (defToggle) {
              defToggle.addEventListener('change', function() {
                if (defToggle.checked) singleBtns[0].click();
              });
            }
          }
        }
      }
  
      nativeContainer.remove();
    } else if (window.__defAudioNativeContainer) {
      window.__defAudioNativeContainer.remove();
      window.__defAudioNativeContainer = null;
    }

    // ── Tagged definition audio: [audio:] JS playback ──
    if (window.__defAudioRawHtml && defAudio) {
      var audioDefs = parseDefinitions(window.__defAudioRawHtml);
      applyDefModeFilter(audioDefs, defMode);
  
      var extractAudioFilenames = function(blockHtml) {
        var tmp = document.createElement('div');
        tmp.innerHTML = blockHtml;
        return window.__extractAudio(tmp).filenames;
      };
  
      var biFilenames = audioDefs.bilingual ? extractAudioFilenames(audioDefs.bilingual) : [];
      var audioMonoKey = audioDefs.monolingual ? 'monolingual' : (audioDefs.LOCKED_monolingual ? 'LOCKED_monolingual' : null);
      var monoFilenames = audioMonoKey ? extractAudioFilenames(audioDefs[audioMonoKey]) : [];
      var hasBiAudio = biFilenames.length > 0;
      var hasMonoAudio = monoFilenames.length > 0;
  
      if (hasBiAudio || hasMonoAudio) {
        var primaryFilenames, secondaryFilenames, primaryType;
  
        if (hasBiAudio && hasMonoAudio) {
          if (window.__monoUnlocked) {
            primaryFilenames = monoFilenames;
            secondaryFilenames = biFilenames;
            primaryType = 'monolingual';
          } else {
            primaryFilenames = biFilenames;
            secondaryFilenames = monoFilenames;
            primaryType = 'bilingual';
          }
        } else {
          primaryFilenames = hasBiAudio ? biFilenames : monoFilenames;
          secondaryFilenames = null;
          primaryType = hasBiAudio ? 'bilingual' : 'monolingual';
        }
  
        var primaryAudios = [];
        for (var pi = 0; pi < primaryFilenames.length; pi++) {
          var pa = document.createElement('audio');
          pa.preload = 'auto';
          pa.src = primaryFilenames[pi];
          document.body.appendChild(pa);
          primaryAudios.push(pa);
          window.__defAudioEls.push(pa);
        }
  
        var secondaryAudios = [];
        if (secondaryFilenames) {
          for (var sk = 0; sk < secondaryFilenames.length; sk++) {
            var sa = document.createElement('audio');
            sa.preload = 'auto';
            sa.src = secondaryFilenames[sk];
            document.body.appendChild(sa);
            secondaryAudios.push(sa);
            window.__defAudioEls.push(sa);
          }
        }
  
        var SVG_DEF = window.__audioSVG;
        var animateBtnDef = window.__animateBtn;
  
        var playGroup = function(audioEls, btn) {
        var mob = window.matchMedia('(hover: none)').matches;
        if (mob) {
          window.__stopAllAudio();
          var gen = window.__webAudioGen;
          var idx = 0;
          (function next() {
            if (idx >= audioEls.length || gen !== window.__webAudioGen) return;
            var cur = idx++;
            window.__playMobile(audioEls[cur].src, btn)
                .then(function() { if (gen === window.__webAudioGen) next(); })
                ['catch'](function() { if (gen === window.__webAudioGen) next(); });
          })();
        } else {
          window.__stopAllAudio(audioEls[0]);
          var idx = 0;
          var playNext = function() {
            if (idx >= audioEls.length) return;
            var cur = idx++;
            audioEls[cur].currentTime = 0;
            audioEls[cur].onended = audioEls[cur].onerror = playNext;
            window.__safePlay(audioEls[cur]);
            if (btn) window.__startPlaying(audioEls[cur], btn);
          };
          playNext();
        }
      };
  
        var audioRow = document.querySelector('.audio-row');
  
        if (hasBiAudio && hasMonoAudio) {
          var makeDefItem = function(label, filenames, audioEls, defRole, defLang) {
            var item = document.createElement('div');
            item.className = 'audio-item bi';
            item.setAttribute('data-audio', 'def');
            item.setAttribute('data-def-role', defRole);
            item.setAttribute('data-def-lang', defLang);
            var btn = document.createElement('a');
            btn.className = 'replay-button';
            btn.href = '#';
            btn.innerHTML = SVG_DEF;
            item.appendChild(btn);
            var lbl = document.createElement('span');
            lbl.className = 'audio-label';
            lbl.textContent = label;
            item.appendChild(lbl);
            if (audioRow) audioRow.appendChild(item);
            var playFn = function() {
              playGroup(audioEls, btn);
              animateBtnDef(btn);
            };
            window.__onTap(btn, function() {
              if (window.matchMedia('(hover: none)').matches) {
                window.__stopAllAudio();
                animateBtnDef(btn);
                window.__playMobile(audioEls[0].src, btn);
              } else {
                window.__stopAllAudio(audioEls[0]);
                audioEls[0].currentTime = 0;
                window.__safePlay(audioEls[0]);
                animateBtnDef(btn);
                window.__startPlaying(audioEls[0], btn);
              }
            }, function() { window.__stopAllAudio(); });
            return playFn;
          };
  
          var playBi, playMono;
          playBi = makeDefItem('Bi-Def', biFilenames,
            window.__monoUnlocked ? secondaryAudios : primaryAudios,
            window.__monoUnlocked ? 'secondary' : 'primary', 'bi');
          playMono = makeDefItem('Mono-Def', monoFilenames,
            window.__monoUnlocked ? primaryAudios : secondaryAudios,
            window.__monoUnlocked ? 'primary' : 'secondary', 'mono');
  
          var playPrimary = window.__monoUnlocked ? playMono : playBi;
          var playSecondary = window.__monoUnlocked ? playBi : playMono;
  
          window.__playLockedDefAudio = playPrimary;
  
          var primaryShown = (primaryType === 'bilingual' && !window.__monoUnlocked) ||
                             (primaryType === 'monolingual' && !!window.__monoUnlocked);
          if (primaryShown) {
            window.__autoPlayDefAudio = playPrimary;
          }
  
          var defToggle = document.getElementById('jp-toggle');
          if (defToggle) {
            defToggle.addEventListener('change', function() {
              if (defToggle.checked) playSecondary();
            });
          }
        } else {
          var defItem = document.createElement('div');
          defItem.className = 'audio-item bi';
          defItem.setAttribute('data-audio', 'def');
          var defBtn = document.createElement('a');
          defBtn.className = 'replay-button';
          defBtn.href = '#';
          defBtn.innerHTML = SVG_DEF;
          defItem.appendChild(defBtn);
          var defLabel = document.createElement('span');
          defLabel.className = 'audio-label';
          defLabel.textContent = 'Definition';
          defItem.appendChild(defLabel);
          if (audioRow) audioRow.appendChild(defItem);
  
          var playPrimary = function() {
            playGroup(primaryAudios, defBtn);
            animateBtnDef(defBtn);
          };
  
          window.__onTap(defBtn, function() {
            if (window.matchMedia('(hover: none)').matches) {
              window.__stopAllAudio();
              animateBtnDef(defBtn);
              window.__playMobile(primaryAudios[0].src, defBtn);
            } else {
              window.__stopAllAudio(primaryAudios[0]);
              primaryAudios[0].currentTime = 0;
              window.__safePlay(primaryAudios[0]);
              animateBtnDef(defBtn);
              window.__startPlaying(primaryAudios[0], defBtn);
            }
          }, function() { window.__stopAllAudio(); });
          window.__playLockedDefAudio = playPrimary;
  
          var primaryShown = (primaryType === 'bilingual' && !window.__monoUnlocked) ||
                             (primaryType === 'monolingual' && !!window.__monoUnlocked);
          if (primaryShown) {
            window.__autoPlayDefAudio = playPrimary;
          } else {
            var defToggle = document.getElementById('jp-toggle');
            if (defToggle) {
              defToggle.addEventListener('change', function() {
                if (defToggle.checked) playPrimary();
              });
            }
          }
        }
      }
    } else if (window.__defAudioRawHtml) {
      window.__defAudioRawHtml = null;
    }

    // ── Definition text-play ──
    if (defAudio && defText) {
      var defLayout = answerEl.getAttribute('data-def-layout');
      var hasDualAudio = !!document.querySelector('.audio-item[data-audio="def"][data-def-lang]');

      function _defTextPlayOpts(lang) {
        var sel = lang
          ? '.audio-item[data-audio="def"][data-def-lang="' + lang + '"]'
          : '.audio-item[data-audio="def"]';
        return {
          play: function() {
            // Delegate to the button's existing tap handler — definition
            // audio elements live in document.body, not inside the audio-item
            var item = document.querySelector(sel);
            if (!item) return;
            var btn = item.querySelector('.replay-button');
            if (btn && btn._tapHandler) btn._tapHandler();
            else if (btn) btn.click();
          },
          getBtn: function() {
            var item = document.querySelector(sel);
            return item ? item.querySelector('.replay-button') : null;
          },
          getAllBtns: function() {
            var item = document.querySelector(sel);
            return item ? Array.from(item.querySelectorAll('.replay-button')) : [];
          }
        };
      }

      if (defLayout === 'bi-only' || defLayout === 'mono-only') {
        if (defEl.innerHTML) {
          window.__linkTextPlay(defEl, 'def', _defTextPlayOpts(null));
        }
      } else if (defLayout === 'dual-bi' || defLayout === 'dual-mono') {
        if (hasDualAudio) {
          var defIsBi = (defLayout === 'dual-bi');
          var defKey = defIsBi ? 'def-bi' : 'def-mono';
          var jpKey = defIsBi ? 'def-mono' : 'def-bi';
          if (defEl.innerHTML) window.__linkTextPlay(defEl, defKey, _defTextPlayOpts(defIsBi ? 'bi' : 'mono'));
          if (jpDefEl.innerHTML) window.__linkTextPlay(jpDefEl, jpKey, _defTextPlayOpts(defIsBi ? 'mono' : 'bi'));
        } else {
          // Dual text but single/no audio — link both defs to same audio
          if (defEl.innerHTML) {
            window.__linkTextPlay(defEl, 'def', _defTextPlayOpts(null));
          }
          if (jpDefEl.innerHTML) {
            window.__linkTextPlay(jpDefEl, 'def', _defTextPlayOpts(null));
          }
        }
      }
    }

    // ── Button → text hover linkage for all audio items ──
    if (window.__linkBtnHoverToText) {
      document.querySelectorAll('.audio-row .audio-item').forEach(function(item) {
        var audioType = item.getAttribute('data-audio');
        var defLang = item.getAttribute('data-def-lang');
        var textKey = (audioType === 'def' && defLang) ? 'def-' + defLang : audioType;
        if (!textKey) return;
        item.querySelectorAll('.replay-button').forEach(function(btn) {
          window.__linkBtnHoverToText(btn, textKey);
        });
      });
    }

    // ── Per-section audio button hiding for definitions ──
    var _defBtnOff = getComputedStyle(document.documentElement)
        .getPropertyValue('--definition-audio-buttons').trim() === 'off';
    if (_defBtnOff) {
        document.querySelectorAll('.audio-item[data-audio="def"]').forEach(function(item) {
            item.setAttribute('data-btn-off', '');
        });
    }

    // ── Mirror audio buttons to bottom row (mobile) ──
    var bottomRow = document.getElementById('audio-row-bottom');
    if (bottomRow) {
      var SVG_BOTTOM = window.__audioSVG;
      var animateBtnBottom = window.__animateBtn;
      var isTategaki = document.documentElement.classList.contains('tategaki');
      var midAudioRow = null;
      if (isTategaki) {
        midAudioRow = document.createElement('div');
        midAudioRow.className = 'mid-audio-row';
        midAudioRow.style.cssText = '--d:80';
      }
      function cloneItemToRow(origItem, targetRow) {
        var clone = document.createElement('div');
        clone.className = 'audio-item';
        var attrs = origItem.attributes;
        for (var ai = 0; ai < attrs.length; ai++) {
          if (attrs[ai].name.indexOf('data-') === 0) {
            clone.setAttribute(attrs[ai].name, attrs[ai].value);
          }
        }
        var origBtns = origItem.querySelectorAll('.replay-button');
        for (var bj = 0; bj < origBtns.length; bj++) {
          (function(origBtn) {
            var btn = document.createElement('a');
            btn.className = 'replay-button';
            btn.href = '#';
            btn.innerHTML = SVG_BOTTOM;
            clone.appendChild(btn);
            window.__onTap(btn, function() {
              if (origBtn._tapHandler) origBtn._tapHandler();
              else origBtn.click();
              animateBtnBottom(btn);
            }, function() { if (origBtn._dblHandler) origBtn._dblHandler(); });
            var obs = new MutationObserver(function() {
              btn.classList.toggle('playing', origBtn.classList.contains('playing'));
              btn.classList.toggle('hover-linked', origBtn.classList.contains('hover-linked'));
            });
            obs.observe(origBtn, { attributes: true, attributeFilter: ['class'] });
            window.__observers.push(obs);
            // Button→text hover linkage for cloned button
            var cloneAudioType = origItem.getAttribute('data-audio');
            var cloneDefLang = origItem.getAttribute('data-def-lang');
            var cloneTextKey = (cloneAudioType === 'def' && cloneDefLang) ? 'def-' + cloneDefLang : cloneAudioType;
            if (cloneTextKey && window.__linkBtnHoverToText) {
              window.__linkBtnHoverToText(btn, cloneTextKey);
            }
          })(origBtns[bj]);
        }
        var origLabel = origItem.querySelector('.audio-label');
        if (origLabel) {
          var lbl = document.createElement('span');
          lbl.className = 'audio-label';
          lbl.textContent = origLabel.textContent;
          clone.appendChild(lbl);
        }
        if (origBtns.length > 0) targetRow.appendChild(clone);
      }
      var topItems = document.querySelectorAll('.audio-row .audio-item:not([data-side="off"]):not([data-btn-off])');
      var hasFrontContent = !!document.querySelector('.front-content [data-side="front"]');
      var hasAnyFrontAudio = !!document.querySelector('.audio-row .audio-item[data-side="front"]:not([data-btn-off])');
      if (isTategaki && !hasFrontContent && hasAnyFrontAudio) {
        bottomRow.setAttribute('data-zone', 'front');
      }
      for (var bi = 0; bi < topItems.length; bi++) {
        (function(origItem) {
          if (isTategaki && midAudioRow) {
            var isFront = !hasFrontContent && origItem.getAttribute('data-side') === 'front';
            if (isFront) {
              cloneItemToRow(origItem, bottomRow);
            } else {
              cloneItemToRow(origItem, midAudioRow);
            }
          } else {
            cloneItemToRow(origItem, bottomRow);
          }
        })(topItems[bi]);
      }
      if (isTategaki) {
        var wordCol = document.querySelector('.word-column');
        if (wordCol) {
          var wpGroup = document.createElement('div');
          wpGroup.className = 'word-pitch-group';
          var targetWord = wordCol.querySelector('.target-word');
          var pitchGraph = wordCol.querySelector('.pitch-graph');
          if (targetWord) wpGroup.appendChild(targetWord);
          if (pitchGraph) wpGroup.appendChild(pitchGraph);
          wordCol.insertBefore(wpGroup, wordCol.firstChild);
          var wpgVisible = Array.prototype.some.call(wpGroup.children, function(c) {
            return getComputedStyle(c).display !== 'none';
          });
          if (!wpgVisible) wpGroup.style.display = 'none';
          if (midAudioRow && midAudioRow.children.length > 0) {
            var imageWrap = wordCol.querySelector('.image-wrap');
            if (imageWrap) wordCol.insertBefore(midAudioRow, imageWrap);
            else wordCol.appendChild(midAudioRow);
            // Top-align mid-audio-row when it's the only visible content in word-column
            var imgVisible = imageWrap && getComputedStyle(imageWrap).display !== 'none';
            if (!wpgVisible && !imgVisible) {
              midAudioRow.style.alignSelf = 'start';
              midAudioRow.style.placeContent = 'start center';
            }
          }
          if (midAudioRow && typeof ResizeObserver !== 'undefined') {
            var rowH = 76, rowGap = 12;
            var gridObs = new ResizeObserver(function(entries) {
              var h = entries[0].contentBoxSize
                ? entries[0].contentBoxSize[0].blockSize
                : entries[0].contentRect.height;
              var maxRows = Math.max(1, Math.floor((h + rowGap) / (rowH + rowGap)));
              var n = midAudioRow.children.length;
              var rows = Math.min(maxRows, n);
              if (rows < n) {
                // Prefer even columns: find largest divisor of n that fits
                // (for n=3, divisors are 1 and 3, so this always picks all-vertical or all-horizontal)
                for (var r = rows; r >= 1; r--) {
                  if (n % r === 0) { rows = r; break; }
                }
              }
              midAudioRow.style.gridTemplateRows = 'repeat(' + rows + ', minmax(' + rowH + 'px, auto))';
            });
            gridObs.observe(midAudioRow);
            window.__observers.push(gridObs);
          }
          // Shrink target word font size if word-column overflows
          // Double-rAF: defer past first paint to avoid layout thrashing before initial render
          requestAnimationFrame(function() {
            requestAnimationFrame(function() {
              var tw = document.querySelector('.target-word');
              var wc = document.querySelector('.word-column');
              var wpg = document.querySelector('.word-pitch-group');
              if (!tw || !wc || !wpg) return;
              var size = parseFloat(getComputedStyle(tw).fontSize);
              var maxH = wc.clientHeight * 0.45;
              var curH = wpg.scrollHeight;
              if (curH <= maxH + 1) return;
              var target = Math.max(16, Math.floor(size * maxH / curH / 2) * 2);
              tw.style.fontSize = target + 'px';
              if (target > 16 && wpg.scrollHeight > maxH + 1) {
                tw.style.fontSize = (target - 2) + 'px';
              }
            });
          });
        }
      }
    }
  
    // Hide empty audio-row-bottom so clearLastMargin targets the real last element
    if (bottomRow && !bottomRow.querySelector('.audio-item:not([data-btn-off])'))
        bottomRow.style.display = 'none';

    // Hide top audio-row if all visible items are hidden by btn-off
    var topRow = document.querySelector('.front .audio-row');
    if (topRow && !topRow.querySelector('.audio-item:not([data-btn-off]):not([data-side="off"])'))
        topRow.style.display = 'none';

    // Hide word-column when all its content is off/on-front (0-dimension placeholder eats margin)
    var wcEl = document.querySelector('.answer .word-column');
    if (wcEl && isTategaki && wcEl.getBoundingClientRect().width === 0) {
        wcEl.style.display = 'none';
    }

    // Clear stale debug-last markings left over from front-side rendering
    document.querySelectorAll('.debug-last').forEach(function(el) {
        el.classList.remove('debug-last');
        el.style.marginBottom = '';
        el.style.marginLeft = '';
    });
    clearLastMargin(document.querySelector('.answer'));
    // If word-column got marked, recurse into it to find the actual last child
    var wc = document.querySelector('.word-column');
    if (wc && wc.classList.contains('debug-last')) {
        wc.classList.remove('debug-last');
        wc.style.marginLeft = '0';
        clearLastMargin(wc);
    }

    // ── Trigger reveal animations after content is ready ──
    var riEls = document.querySelectorAll('.answer > [style*="--d"], .word-column [style*="--d"]');
    for (var ri = 0; ri < riEls.length; ri++) riEls[ri].classList.add('ri');
    var rtEls = document.querySelectorAll('.front-content .target-word rt, .front-content .sentence rt');
    requestAnimationFrame(function() { requestAnimationFrame(function() {
      for (var rti = 0; rti < rtEls.length; rti++) rtEls[rti].classList.add('rt-ri');
    }); });
    if (isTategaki) {
      var ciEl = document.querySelector('.card-inner');
      if (ciEl) ciEl.classList.add('tate-expand');
    }
  
    // ── Auto-play back-side audio (word/sentence set to "back", then definition) ──
    setTimeout(function() {
      var items = document.querySelectorAll('.audio-row .audio-item[data-side="back"]');
      var queue = [];
      var animateBtn = window.__animateBtn;
      items.forEach(function(item) {
        var btns = item.querySelectorAll('.replay-button');
        if (item._jsAudios && item._jsAudios.length) {
          for (var j = 0; j < item._jsAudios.length; j++) {
            queue.push({ audio: item._jsAudios[j], btn: btns[j] });
          }
        } else {
          var els = item.querySelectorAll('audio');
          for (var j = 0; j < els.length; j++) {
            queue.push({ audio: els[j], btn: btns[j] });
          }
        }
      });
      var gen = window.__webAudioGen;
      var i = 0;
      (function playNext() {
        if (gen !== window.__webAudioGen) return;
        if (i < queue.length) {
          var entry = queue[i++];
          if (entry.btn) animateBtn(entry.btn);
          window.__playMobile(entry.audio.src, entry.btn)
            .then(function() { if (gen === window.__webAudioGen) playNext(); })
            ['catch'](function() { if (gen === window.__webAudioGen) playNext(); });
        } else if (window.__autoPlayDefAudio) {
          window.__autoPlayDefAudio();
        }
      })();
    }, 0);
  }
  _renderBack();
  })();
  </script>
  
  <script>
  (function() {
    var HANDLER_KEY = '__audioHandler';
    var animateBtn = window.__animateBtn;
    var _lastKey = null, _lastKeyTime = 0, _DBL_MS = 350;
    var _rs = getComputedStyle(document.documentElement);
    var K_WORD = (_rs.getPropertyValue('--hotkey-word-audio').trim() || 'n').toLowerCase();
    var K_SENT = (_rs.getPropertyValue('--hotkey-sentence-audio').trim() || 'h').toLowerCase();
    var K_DEF  = _rs.getPropertyValue('--hotkey-definition-audio').trim() || ',';
    var K_ALL  = (_rs.getPropertyValue('--hotkey-play-all').trim() || 'z').toLowerCase();
    var K_STOP = _rs.getPropertyValue('--hotkey-stop-all').trim() || '?';
    function isDbl(key) {
      var now = Date.now();
      if (_lastKey === key && now - _lastKeyTime < _DBL_MS) { _lastKey = null; _lastKeyTime = 0; return true; }
      _lastKey = key; _lastKeyTime = now; return false;
    }
    function play(item) {
      if (!item) return;
      window.__playItemAudios(item);
    }
    function playAll() {
      var items = document.querySelectorAll('.audio-row .audio-item:not([data-side="off"])');
      var queue = [];
      items.forEach(function(item) {
        var btns = item.querySelectorAll('.replay-button');
        if (item._jsAudios && item._jsAudios.length) {
          for (var j = 0; j < item._jsAudios.length; j++) {
            queue.push({ audio: item._jsAudios[j], btn: btns[j], js: true });
          }
        } else {
          var els = item.querySelectorAll('audio');
          for (var j = 0; j < els.length; j++) {
            queue.push({ audio: els[j], btn: btns[j], js: false });
          }
        }
      });
      if (!queue.length) return false;
      window.__stopAllAudio();
      var k = 0;
      function next() {
        if (k >= queue.length) {
          if (window.__playLockedDefAudio) window.__playLockedDefAudio();
          return;
        }
        var entry = queue[k++];
        entry.audio.currentTime = 0;
        window.__safePlay(entry.audio);
        if (entry.btn) animateBtn(entry.btn);
        if (entry.js) window.__startPlaying(entry.audio, entry.btn);
        entry.audio.onended = entry.audio.onerror = next;
      }
      next();
      return true;
    }
    function handler(ev) {
      var el = ev.target;
      if (el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable)) return;
      var wordItem = document.querySelector('.audio-row .audio-item[data-audio="word"]:not([data-side="off"])');
      var sentItem = document.querySelector('.audio-row .audio-item[data-audio="sentence"]:not([data-side="off"])');
      var defItem = document.querySelector('.audio-row .audio-item[data-audio="def"]');
      var k = ev.key.toLowerCase();
      if (k === K_WORD) { ev.preventDefault(); ev.stopPropagation(); if (isDbl(K_WORD)) window.__stopAllAudio(); else play(wordItem); }
      else if (k === K_SENT) { ev.preventDefault(); ev.stopPropagation(); if (isDbl(K_SENT)) window.__stopAllAudio(); else play(sentItem); }
      else if (k === K_DEF) {
        ev.preventDefault(); ev.stopPropagation();
        if (isDbl(K_DEF)) { window.__stopAllAudio(); }
        else if (window.__playLockedDefAudio) window.__playLockedDefAudio();
        else play(defItem);
      }
      else if (k === K_ALL) { if (playAll()) { ev.preventDefault(); ev.stopPropagation(); } }
      else if (k === K_STOP) { ev.preventDefault(); ev.stopPropagation(); if (window.__stopAllAudio) window.__stopAllAudio(); }
    }
    if (window[HANDLER_KEY]) {
      window.removeEventListener('keydown', window[HANDLER_KEY], true);
    }
    window[HANDLER_KEY] = handler;
    window.addEventListener('keydown', handler, { capture: true });
  })();
  </script>
  
  <script>
  (function() {
    var HANDLER_KEY = '__jpDefHandler';
    function animateToggle(label) {
      label.style.color = 'var(--text-1)';
      label.style.borderColor = 'var(--flash-border)';
      label.style.background = 'var(--flash-bg)';
      setTimeout(function() {
        label.style.color = '';
        label.style.borderColor = '';
        label.style.background = '';
      }, 350);
    }
    var _rs = getComputedStyle(document.documentElement);
    var K_JP = _rs.getPropertyValue('--hotkey-jp-toggle').trim() || '.';
    function handler(ev) {
      if (ev.key === K_JP) {
        var cb = document.getElementById('jp-toggle');
        if (cb) {
          ev.preventDefault();
          ev.stopPropagation();
          cb.checked = !cb.checked;
          cb.dispatchEvent(new Event('change'));
          var label = document.querySelector('.jp-def-toggle');
          if (label) animateToggle(label);
        }
      }
    }
    if (window[HANDLER_KEY]) {
      window.removeEventListener('keydown', window[HANDLER_KEY], true);
    }
    window[HANDLER_KEY] = handler;
    window.addEventListener('keydown', handler, { capture: true });
  
    var jpToggle = document.getElementById('jp-toggle');
    if (jpToggle) {
      jpToggle.addEventListener('change', function() {
        if (!jpToggle.checked) {
          window.__stopAllAudio();
        }
      });
    }
  })();
  </script>
  
  <script>
  // Tategaki: convert ASCII digits to full-width and wrap bracketed digit content
  (function() {
      if (!document.documentElement.classList.contains('tategaki')) return;
  
      var SKIP = /^(script|style|noscript)$/i;
      var BRACKET_DIGIT = /\[[^\]]*\d[^\]]*\]/g;
      var DIGIT = /[0-9]/;
      var TO_FW = function(ch) { return String.fromCharCode(ch.charCodeAt(0) + 0xFEE0); };
  
      function walk(root, regex, handler) {
          var walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
              acceptNode: function(n) {
                  if (SKIP.test(n.parentNode.nodeName) || n.parentNode.closest('.hor'))
                      return NodeFilter.FILTER_REJECT;
                  return regex.test(n.nodeValue) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
              }
          }, false);
          var nodes = [];
          while (walker.nextNode()) nodes.push(walker.currentNode);
          nodes.forEach(function(n) { handler(n, regex); });
      }
  
      function wrapBrackets(node, re) {
          var txt = node.nodeValue;
          var frag = document.createDocumentFragment();
          var last = 0, m;
          re.lastIndex = 0;
          while ((m = re.exec(txt))) {
              if (m.index > last) frag.appendChild(document.createTextNode(txt.slice(last, m.index)));
              var span = document.createElement('span');
              span.className = 'hor';
              span.textContent = m[0];
              frag.appendChild(span);
              last = re.lastIndex;
          }
          if (last < txt.length) frag.appendChild(document.createTextNode(txt.slice(last)));
          node.parentNode.replaceChild(frag, node);
      }
  
      function convertDigits(node) {
          node.nodeValue = node.nodeValue.replace(/[0-9]/g, TO_FW);
      }
  
      var answer = document.querySelector('.answer');
      if (!answer) return;
      walk(answer, BRACKET_DIGIT, wrapBrackets);
      walk(answer, DIGIT, convertDigits);
  })();
  </script>

<script>
// Center hyphens between pitch-num glyphs (Latin baseline sits too low next to them)
(function() {
    var glyphs = document.querySelectorAll('.pitch-num');
    for (var i = 0; i < glyphs.length; i++) {
        var node = glyphs[i].nextSibling;
        if (node && node.nodeType === 3 && node.nodeValue.trim() === '-'
            && node.nextSibling && node.nextSibling.classList
            && node.nextSibling.classList.contains('pitch-num')) {
            var span = document.createElement('span');
            span.className = 'hc';
            span.textContent = node.nodeValue;
            node.parentNode.replaceChild(span, node);
        }
    }
})();
</script>

