<div class="card-inner">
<div class="back">
    <div class="audio-row">
        <div class="audio-item">
            {{Word Audio}}
            <span class="audio-label">Word</span>
        </div>
        <div class="audio-item">
            {{Sentence Audio}}
            <span class="audio-label">Sentence</span>
        </div>
        {{#Definition Audio}}
        <div class="audio-item">
            {{Definition Audio}}
            <span class="audio-label">Definition</span>
        </div>
        {{/Definition Audio}}
    </div>
    <div class="answer">
        <h1 class="target-word ri" style="--d:0" id="target-word"></h1>
        <div class="pitch-graph ri" style="--d:50" id="pitch-graph"></div>
        {{#Image}}
        <div class="image-wrap ri" style="--d:95">{{Image}}</div>
        {{/Image}}
        <p class="sentence ri" style="--d:135" id="sentence"></p>
        <div class="divider ri" style="--d:170"></div>
        <p class="def ri" style="--d:200" id="def-bilingual"></p>
        <div class="jp-def-section ri" style="--d:225" id="jp-def-section">
            <input type="checkbox" id="jp-toggle" class="jp-def-input">
            <label for="jp-toggle" class="jp-def-toggle">日本語</label>
            <div class="jp-def-wrap">
                <p class="jp-def" id="def-monolingual"></p>
            </div>
        </div>
    </div>
</div>
</div>

<!-- Hidden raw fields for JS processing -->
<div id="raw-word" style="display:none">{{Word}}</div>
<div id="raw-sentence" style="display:none">{{Sentence}}</div>
<div id="raw-definition" style="display:none">{{Definition}}</div>

<script>
(function() {
// ── config.js ──
const config = {
  no_text: false, size_unit: 25, font_size: 24, text_dx: -12,
  x_step: 50, circle_radius: 5.25, devoiced_circle_width: 1.5,
  devoiced_circle_radius: 17, devoiced_stroke_disarray: "2 3",
  devoiced_rectangle_padding: 5, stroke_width: 2.5, graph_height: 40,
  graph_visible_height: 100, graph_horizontal_padding: 6,
  graph_font: "'Noto Serif JP', 'Hiragino Mincho ProN', 'Yu Mincho', serif",
  convert_reading: 'katakana', stroke_dasharray: '4',
};

// ── kana.js ──
const _hiragana = [
  'が','ぎ','ぐ','げ','ご','ざ','じ','ず','ぜ','ぞ','だ','ぢ','づ','で','ど',
  'ば','び','ぶ','べ','ぼ','ぱ','ぴ','ぷ','ぺ','ぽ','あ','い','う','え','お',
  'か','き','く','け','こ','さ','し','す','せ','そ','た','ち','つ','て','と',
  'な','に','ぬ','ね','の','は','ひ','ふ','へ','ほ','ま','み','む','め','も',
  'や','ゆ','よ','ら','り','る','れ','ろ','わ','を','ん','ぁ','ぃ','ぅ','ぇ','ぉ',
  'ゃ','ゅ','ょ','っ',
];
const _katakana = [
  'ガ','ギ','グ','ゲ','ゴ','ザ','ジ','ズ','ゼ','ゾ','ダ','ヂ','ヅ','デ','ド',
  'バ','ビ','ブ','ベ','ボ','パ','ピ','プ','ペ','ポ','ア','イ','ウ','エ','オ',
  'カ','キ','ク','ケ','コ','サ','シ','ス','セ','ソ','タ','チ','ツ','テ','ト',
  'ナ','ニ','ヌ','ネ','ノ','ハ','ヒ','フ','ヘ','ホ','マ','ミ','ム','メ','モ',
  'ヤ','ユ','ヨ','ラ','リ','ル','レ','ロ','ワ','ヲ','ン','ァ','ィ','ゥ','ェ','ォ',
  'ャ','ュ','ョ','ッ',
];
const k2h = {}, h2k = {};
_katakana.forEach((k, i) => { k2h[k] = _hiragana[i]; h2k[_hiragana[i]] = k; });

function toHiragana(s) { return [...s].map(c => k2h[c] || c).join(''); }
function toKatakana(s) { return [...s].map(c => h2k[c] || c).join(''); }

const EQ_SOUNDS_HIRA = {
  'ぢ':'じ','づ':'ず','を':'お','れい':'れー','めい':'めー','べい':'べー',
  'けい':'けー','ぐう':'ぐー','ごう':'ごー','ずう':'ずー','づう':'ずー',
  'づー':'ずー','ぞう':'ぞー','どう':'どー','どお':'どー','ぶう':'ぶー',
  'ぼう':'ぼー','ぷう':'ぷー','ぽう':'ぽー','うう':'うー','おう':'おー',
  'おお':'おー','くう':'くー','こう':'こー','すう':'すー','そう':'そー',
  'つう':'つー','とう':'とー','とお':'とー','こお':'こー','ぬう':'ぬー',
  'のう':'のー','ふう':'ふー','ほう':'ほー','ほお':'ほー','むう':'むー',
  'もう':'もー','よう':'よー','るう':'るー','ろう':'ろー','ぅう':'ぅー',
  'ぉう':'ぉー','ょう':'ょー','ゆう':'ゆー','いい':'いー','ちい':'ちー',
  'せい':'せー','じい':'じー','かあ':'かー','ゅう':'ゅー','ぜい':'ぜー',
  'つづ':'つず','じゃあ':'じゃー',
};
const EQUIVALENT_SOUNDS = {...EQ_SOUNDS_HIRA};
for (const [k, v] of Object.entries(EQ_SOUNDS_HIRA)) {
  EQUIVALENT_SOUNDS[toKatakana(k)] = toKatakana(v);
}

function unifyRepr(reading) {
  for (const [k, v] of Object.entries(EQUIVALENT_SOUNDS)) {
    reading = reading.replaceAll(k, v);
  }
  return reading;
}
function literalPronunciation(text) { return toKatakana(unifyRepr(text)); }

// ── parse.js ──
const GHOST_PARTICLE = '+';
const DEVOICED_PREFIX = '*';
const LITERAL_PREFIX = '\\';
const SENT_HIDDEN = ['|', GHOST_PARTICLE];
const PITCH_BREAKS = [...SENT_HIDDEN, ',', '、'];

function normalizeForParsing(expr) {
  expr = expr.replace(/\//g, ';');
  expr = expr.replace(/<br>/gi, ' . ');
  expr = expr.replace(/<[^<>]+>/gi, '');
  expr = expr.replace(/([。!?！？])/g, ' $1 .');
  expr = expr.replace(/([「」|、､])/g, ' $1 ');
  expr = expr.replace(/([^ ]), /g, ' $1 , ');
  return expr;
}

function splitToSentences(expr) {
  return expr.split(/[.\n]+/).map(s => s.trim()).filter(Boolean);
}

function splitToSections(sentence) {
  return sentence.split(/[\t\s\u3000]+/).filter(Boolean);
}

function detachGhostParticle(text) {
  return text.replace(/(\++)[\s\n.]*$/, ' $1');
}

function furiganaToReading(word) {
  return word.split(' ').map(part => part.replace(/([^\[\]]*\[|])/g, '')).join('');
}

function filterKana(reading) {
  return reading.replace(/[^\u3040-\u309F\u30A0-\u30FF\*\+\\]/g, '');
}

function kanaToMoraes(kana) {
  return kana.match(/(?:\*\\?|\\\*?)?.[ァィゥェォャュョぁぃぅぇぉゃゅょ]?/g) || [];
}

function splitToMoras(reading) {
  const kana = filterKana(reading);
  const raw = kanaToMoraes(kana);
  return raw.map(m => {
    let devoiced = false, literal = false;
    if (m.startsWith(DEVOICED_PREFIX)) { devoiced = true; m = m.slice(1); }
    if (m.startsWith(LITERAL_PREFIX)) { literal = true; m = m.slice(1); }
    if (m.startsWith(DEVOICED_PREFIX)) { devoiced = true; m = m.slice(1); }
    return { text: m, devoiced, literal };
  });
}

function splitSection(raw) {
  const m = raw.match(/^([^:]+)(:)?(.*)$/);
  if (m) return { word: m[1], sep: m[2] || null, accent: m[3] || '' };
  return { word: raw, sep: null, accent: '' };
}

function splitAccent(raw) {
  if (!raw && raw !== '') raw = '';
  let m = raw.match(/^(p)?([a-zA-Z])?(-)?(\d)?(-)?$/);
  if (m) {
    return {
      is_particle: m[1] || null,
      role: m[2] || m[1] || null,
      allLow: !!(m[3] || m[5]),
      pitch: m[4] || null,
    };
  }
  m = raw.match(/^([a-zA-Z]{1,2}):([hlHL]+)$/);
  if (m) {
    return { role: m[1], levels: m[2], keihan: true };
  }
  return { role: null, pitch: null };
}

const SEPARATORS = [';', '|', ',', '、', '+', '「', '」'];

function mergeFragments(sections) {
  const result = [];
  let pending = [];
  for (const raw of sections) {
    if (SEPARATORS.includes(raw)) {
      result.push(...pending);
      pending = [];
      result.push(raw);
      continue;
    }
    const { sep } = splitSection(raw);
    if (sep == null) {
      pending.push(raw);
    } else {
      if (pending.length) {
        const merged = [...pending, raw.replace(/:.*$/, '')].join(' ');
        const accent = raw.replace(/^[^:]*:/, '');
        result.push(merged + ':' + accent);
        pending = [];
      } else {
        result.push(raw);
      }
    }
  }
  result.push(...pending);
  return result;
}

function splitMultiplePitchNotations(sequences) {
  const result = [];
  for (const seq of sequences) {
    const alternatives = seq.map(raw => {
      const sec = splitSection(raw);
      if (sec.sep && sec.accent.includes(',')) {
        return sec.accent.split(',').map(a => `${sec.word}:${a.trim()}`);
      }
      return [raw];
    });
    let combos = [[]];
    for (const alts of alternatives) {
      combos = combos.flatMap(prev => alts.map(a => [...prev, a]));
    }
    result.push(...combos);
  }
  return result;
}

// ── section.js ──
const RoleFromValue = {
  'h':'heiban','a':'atamadaka','n':'nakadaka','o':'odaka','k':'kifuku',
  'b':'black','w':'white','s':'setsubigo','e':'empty','p':'particle',
  'H':'keihan_heiban','A':'keihan_atamadaka','N':'keihan_nakadaka',
  'L':'keihan_low_heiban','M':'keihan_low_nakadaka','O':'keihan_low_odaka',
  'K':'keihan_kifuku',
};

function isEmptyParticle(word) { return /^[|,、]$/.test(word); }

function determineRoleKeihan(rawRole) {
  const val = String(rawRole || 'H');
  return RoleFromValue[val.toUpperCase()] || RoleFromValue[val.toLowerCase()] || 'keihan_heiban';
}

function determineLevelsKeihan(levels, moraes) {
  const arr = [...String(levels).toLowerCase()];
  while (arr.length < moraes.length) arr.push(arr[arr.length - 1]);
  return arr;
}

function guessRoleFromPitchNum(moraes, pitchN) {
  if (pitchN == null) return 'heiban';
  const n = parseInt(pitchN);
  if (n === 0) return 'heiban';
  if (n === 1) return 'atamadaka';
  if (n === moraes.length) return 'odaka';
  if (n < moraes.length) return 'nakadaka';
  return 'heiban';
}

function determineRoleTokyo(sd) {
  if (sd.moraes.length === 0 || isEmptyParticle(sd.word)) return 'empty';
  if (sd.sep == null) return 'particle';
  if (sd.accent.role == null && sd.accent.pitch == null) return 'particle';
  if (sd.accent.role == null) return guessRoleFromPitchNum(sd.moraes, sd.accent.pitch);
  return RoleFromValue[sd.accent.role.toLowerCase()] || 'heiban';
}

function determinePitchTokyo(sd) {
  if (sd.accent.allLow) return -1;
  if (sd.sep && sd.accent.pitch != null) return parseInt(sd.accent.pitch);
  const role = sd.accent.role;
  if (role === 'heiban' || role === 'setsubigo') return 0;
  if (role === 'atamadaka') return 1;
  if (role === 'nakadaka' || role === 'kifuku') return 2;
  if (role === 'odaka') return sd.moraes.length;
  if (role === 'particle') return null;
  if (role === 'empty') return -1;
  return 0;
}

function adjustKana(text) {
  if (config.convert_reading === 'katakana') {
    const literals = [];
    text = text.replace(/\\(\*?)(.)/g, (_, star, ch) => {
      literals.push(ch);
      return star + '\uE000';
    });
    const devoiced = new Set();
    let clean = '';
    for (const ch of text) {
      if (ch === DEVOICED_PREFIX) devoiced.add(clean.length);
      else clean += ch;
    }
    clean = literalPronunciation(clean);
    text = '';
    for (let i = 0; i < clean.length; i++) {
      if (devoiced.has(i)) text += DEVOICED_PREFIX;
      text += clean[i];
    }
    let j = 0;
    text = text.replace(/\uE000/g, () => LITERAL_PREFIX + toKatakana(literals[j++]));
    return text;
  }
  if (config.convert_reading === 'hiragana') return toHiragana(text);
  return text;
}

function prepareMoras(word) {
  let reading = furiganaToReading(word);
  reading = adjustKana(reading);
  return splitToMoras(reading);
}

class Section {
  constructor(rawSection) {
    this.raw = rawSection;
    this._d = splitSection(rawSection);
    this._d.moraes = prepareMoras(this._d.word || '');
    this._d.accent = splitAccent(this._d.accent || '');
    this._initAccent();
  }

  _initAccent() {
    const a = this._d.accent;
    if (a.keihan) {
      a.role = determineRoleKeihan(a.role);
      a.levels = determineLevelsKeihan(a.levels, this._d.moraes);
    } else {
      a.keihan = false;
      a.role = determineRoleTokyo(this._d);
      a.pitch = determinePitchTokyo(this._d);
    }
  }

  get isTape() { return this.raw === ';'; }
  get isParticle() { return !!this._d.accent.is_particle; }

  get word() { return this._d.word.replaceAll(DEVOICED_PREFIX, '').replaceAll(LITERAL_PREFIX, ''); }

  get moraes() {
    const m = this._d.moraes;
    if ((this.role === 'particle' || this.isParticle) && m.length === 1 && !m[0].literal) {
      if (m[0].text === 'ハ') return [{ text: 'ワ', devoiced: m[0].devoiced, literal: false }];
      if (m[0].text === 'ヘ') return [{ text: 'エ', devoiced: m[0].devoiced, literal: false }];
    }
    return m;
  }

  get role() { return this._d.accent.role; }

  get classname() {
    if (this.isParticle) {
      return [...new Set(['particle', this.role])].join(' ');
    }
    return this.role;
  }

  get pitch() { return this._d.accent.pitch; }
  set pitch(v) { this._d.accent.pitch = v; }

  get levels() { return this._d.accent.levels; }
  set levels(v) { this._d.accent.levels = v; }

  get isKeihan() { return !!this._d.accent.keihan; }
}

const H = 'h', L = 'l';

function buildLevelsTokyo(section, lastLow) {
  if (section.pitch == null) section.pitch = lastLow ? -1 : -2;
  if (section.pitch === -1) return section.moraes.map(() => L);
  if (section.pitch === -2) return section.moraes.map(() => H);
  if (section.pitch === 1) return [H, ...section.moraes.slice(1).map(() => L)];

  return section.moraes.map((_, i) => {
    if (i === 0) return lastLow ? L : H;
    return (i < section.pitch || section.pitch === 0) ? H : L;
  });
}

function calcLastWordEndedLow(section, lastLow) {
  if (section.role === 'empty' && !PITCH_BREAKS.includes(section.word)) return lastLow;
  if (section.pitch === 1) return true;
  if (section.pitch === 0 || section.pitch === -2) return false;
  return section.moraes.length >= section.pitch;
}

function buildHighLow(sequence) {
  let lastLow = true;
  for (const section of sequence) {
    if (section.isKeihan) {
      lastLow = section.levels[section.levels.length - 1] === L;
    } else {
      section.levels = buildLevelsTokyo(section, lastLow);
      lastLow = calcLastWordEndedLow(section, lastLow);
    }
  }
  return sequence;
}

function parseSections(seq) { return seq.map(s => new Section(s)); }

function filterEmptyMoraes(sequence) {
  return sequence.filter(s =>
    s.moraes.length || PITCH_BREAKS.includes(s.word) || s.isTape
  );
}

// ── graph.js ──
class Line {
  constructor() { this.x1 = this.y1 = this.x2 = this.y2 = null; this._tape = false; }
  start(x, y, tape = false) { this.x1 = x; this.y1 = y; this._tape = tape; return this; }
  end(x, y) { this.x2 = x; this.y2 = y; return this; }
  get isUnfinished() { return this.x1 != null && this.y1 != null; }
  get isCompleted() { return this.x2 != null && this.y2 != null; }

  adjustToRadius(r) {
    const tan = config.graph_height / config.x_step;
    const denom = Math.sqrt(1 + tan * tan);
    const sin = tan / denom, cos = 1 / denom;
    const oy = r * sin, ox = r * cos;
    if (this.y1 === this.y2) { this.x1 += r; this.x2 -= r; }
    else if (this.y1 > this.y2) { this.x1 += ox; this.y1 -= oy; this.x2 -= ox; this.y2 += oy; }
    else { this.x1 += ox; this.y1 += oy; this.x2 -= ox; this.y2 -= oy; }
    return this;
  }

  draw() {
    let s = `<line stroke="black" stroke-width="${config.stroke_width}" x1="${this.x1.toFixed(3)}" y1="${this.y1.toFixed(3)}" x2="${this.x2.toFixed(3)}" y2="${this.y2.toFixed(3)}" />`;
    if (this._tape) s = s.replace('<line', `<line stroke-dasharray="${config.stroke_dasharray}"`);
    return s;
  }
}

class Path {
  constructor() { this.lines = []; }
  get last() { return this.lines[this.lines.length - 1]; }
  startAt(x, y) { this.lines.push(new Line().start(x, y)); }
  goTo(x, y) { this.last.end(x, y); }
  push(x, y) {
    if (this.lines.length === 0) { this.startAt(x, y); }
    else if (this.last.isCompleted) { this.startAt(this.last.x2, this.last.y2); this.goTo(x, y); }
    else { this.goTo(x, y); }
  }
  draw() {
    return this.lines
      .filter(l => l.isCompleted)
      .map(l => { l.adjustToRadius(config.circle_radius); return l.draw(); })
      .join('');
  }
}

function shouldConnect(section, prev) {
  if (prev.isTape) return true;
  if (section.role === 'empty' || prev.role === 'empty') return false;
  return true;
}

function makeCircle(x, y) {
  return `<circle fill="black" stroke="black" stroke-width="${config.stroke_width}" cx="${x}" cy="${y}" r="${config.circle_radius}"></circle>`;
}

function makeDevoicedCircle(mora, x, y) {
  if (mora.text.length === 1) {
    const cx = x + config.font_size / 2 + config.text_dx;
    const cy = y + config.text_dx + Math.ceil(config.stroke_width);
    return `<circle class="devoiced" cx="${cx}" cy="${cy}" stroke-width="${config.devoiced_circle_width}" r="${config.devoiced_circle_radius}" stroke-dasharray="${config.devoiced_stroke_disarray}" />`;
  }
  const fs = config.font_size, r = config.devoiced_circle_radius;
  const ry = y - config.font_size - Math.floor(config.stroke_width);
  const pad = config.devoiced_rectangle_padding;
  return `<rect class="devoiced" x="${x - fs - pad}" y="${ry}" width="${fs * 2 + pad * 2}" height="${r * 2}" rx="${r}" stroke-width="${config.devoiced_circle_width}" stroke-dasharray="${config.devoiced_stroke_disarray}" />`;
}

function makeGroup(elements, cls) { return `<g class="${cls}">${elements.join('')}</g>`; }
function makeSvg(contents, w, h, vh) {
  return `<svg style="font-family: ${config.graph_font}" viewBox="0 0 ${w} ${h}" height="${vh}px" xmlns="http://www.w3.org/2000/svg">${contents}</svg>`;
}
function makeText(mora, x, y, dx) {
  const cls = mora.devoiced ? ' class="devoiced"' : '';
  return `<text${cls} font-size="${config.font_size}px" fill="black" x="${x}" y="${y}" dx="${dx}">${mora.text}</text>`;
}

function calcSvgWidth(sequence, step) {
  return sequence.reduce((sum, s) => sum + (s.role !== 'empty' ? s.moraes.length : 0), 0) * step
    + config.graph_horizontal_padding * 2;
}

function makeGraph(sequence) {
  sequence = filterEmptyMoraes(sequence);
  if (!sequence.length) return null;

  let xPos = config.size_unit + config.graph_horizontal_padding;
  let yPos = config.size_unit;
  const heightHigh = config.size_unit;
  const heightLow = heightHigh + config.graph_height;
  const xStep = config.x_step;
  const heightKana = heightLow + xStep;

  const circles = [], paths = [], text = [];

  for (let i = 0; i < sequence.length; i++) {
    const section = sequence[i];
    if (section.role === 'empty' || section.isTape) continue;

    const wordCircles = [], textMoraes = [];
    const path = new Path();
    const connector = new Line();

    if (i > 0 && shouldConnect(section, sequence[i - 1])) {
      connector.start(xPos - xStep, yPos, sequence[i - 1].isTape);
    }

    const moraes = section.moraes;
    for (let j = 0; j < moraes.length; j++) {
      const mora = moraes[j];
      let moraLevel;
      if (mora.text === 'っ' || mora.text === 'ッ') {
        moraLevel = (j === 1 && section.levels[j - 1] === L) ? section.levels[j - 1] : section.levels[j];
      } else {
        moraLevel = section.levels[j];
      }
      yPos = moraLevel === H ? heightHigh : heightLow;
      wordCircles.push(makeCircle(xPos, yPos));
      path.push(xPos, yPos);

      if (j === 0 && connector.isUnfinished) {
        connector.end(xPos, yPos);
      }

      if (mora.text !== GHOST_PARTICLE) {
        if (mora.devoiced) {
          textMoraes.push(makeDevoicedCircle(mora, xPos, heightKana));
        }
        textMoraes.push(makeText(mora, xPos, heightKana, config.text_dx * mora.text.length));
      }

      xPos += xStep;
    }

    circles.push(makeGroup(wordCircles, section.classname));
    paths.push(makeGroup([path.draw()], section.classname));
    text.push(makeGroup(textMoraes, section.classname));

    if (connector.isCompleted) {
      paths.push(makeGroup([connector.adjustToRadius(config.circle_radius).draw()], 'connector'));
    }
  }

  const content = [makeGroup(paths, 'paths'), makeGroup(circles, 'circles')];
  const svgWidth = calcSvgWidth(sequence, xStep);
  const svgHeightText = heightKana + config.size_unit;
  const svgHeightNoText = heightLow + config.size_unit;

  let svgHeight, visibleHeight;
  if (config.no_text) {
    svgHeight = svgHeightNoText;
    visibleHeight = Math.round((svgHeightNoText / svgHeightText) * config.graph_visible_height);
  } else {
    svgHeight = svgHeightText;
    visibleHeight = config.graph_visible_height;
    content.push(makeGroup(text, 'text'));
  }

  return makeSvg(content.join(''), svgWidth, svgHeight, visibleHeight);
}

// ── sentence.js ──
function wordToRubyFragment(fragment) {
  const re = /([^\[\]]+)\[([^\]]+)\]/g;
  let result = '';
  let lastIndex = 0;
  let match;
  while ((match = re.exec(fragment)) !== null) {
    if (match.index > lastIndex) {
      result += fragment.slice(lastIndex, match.index);
    }
    result += `<ruby>${match[1]}<rt>${match[2]}</rt></ruby>`;
    lastIndex = re.lastIndex;
  }
  if (lastIndex < fragment.length) {
    result += fragment.slice(lastIndex);
  }
  return result;
}

function wordToRuby(word) {
  word = word.replaceAll(DEVOICED_PREFIX, '');
  word = word.replaceAll(LITERAL_PREFIX, '');
  return word.split(' ').map(wordToRubyFragment).join('');
}

function makeColoredSentence(sequence) {
  const spans = [];
  for (const section of sequence) {
    if (SENT_HIDDEN.includes(section.word) || /^\++$/.test(section.word) || section.isTape) continue;
    spans.push(`<span class="${section.classname}">${wordToRuby(section.word)}</span>`);
  }
  return spans.join('');
}

// ── makeSequences glue ──
function makeSequences(expr) {
  expr = normalizeForParsing(expr);
  let sentences = splitToSentences(expr);
  sentences = sentences.map(detachGhostParticle);
  let bySection = sentences.map(splitToSections);
  bySection = bySection.map(mergeFragments);
  bySection = splitMultiplePitchNotations(bySection);
  let sequences = bySection.map(parseSections);
  sequences = sequences.map(buildHighLow);
  return sequences;
}

// ── parseDefinitions ──
function parseDefinitions(html) {
  const defs = {};
  const re = /<!--\s*def-type="(\w+)"\s*-->([\s\S]*?)<!--\s*def-end\s*-->/g;
  let m;
  while ((m = re.exec(html)) !== null) {
    defs[m[1]] = m[2].trim();
  }
  return defs;
}

// ── Render (deferred for Anki front→back transitions) ──
function _renderBack() {
  var wordRaw = document.getElementById('raw-word');
  if (!wordRaw) return setTimeout(_renderBack, 10);

  wordRaw = wordRaw.textContent.trim();
  var sentRaw = document.getElementById('raw-sentence').textContent.trim();
  var defHtml = document.getElementById('raw-definition').innerHTML;

  var targetEl = document.getElementById('target-word');
  var graphEl = document.getElementById('pitch-graph');
  var sentEl = document.getElementById('sentence');
  var defEl = document.getElementById('def-bilingual');
  var jpDefSection = document.getElementById('jp-def-section');
  var jpDefEl = document.getElementById('def-monolingual');

  // Word → target word + pitch graph
  if (wordRaw) {
    var wordSeqs = makeSequences(wordRaw);

    if (wordSeqs.length > 0) {
      // Target word display uses first sequence
      targetEl.innerHTML = makeColoredSentence(wordSeqs[0]);

      // Pitch graphs for ALL sequences (stacked)
      var svgs = [];
      for (var s = 0; s < wordSeqs.length; s++) {
        var svg = makeGraph(wordSeqs[s]);
        if (svg) svgs.push(svg);
      }
      if (svgs.length > 0) {
        graphEl.innerHTML = svgs.join('');
      } else {
        graphEl.style.display = 'none';
      }
    } else {
      graphEl.style.display = 'none';
    }
  } else {
    graphEl.style.display = 'none';
  }

  // Sentence → colored sentence
  if (sentRaw) {
    var sentSeqs = makeSequences(sentRaw);
    if (sentSeqs.length > 0) {
      var hasAccent = sentSeqs[0].some(function(s) {
        return s.role !== 'particle' && s.role !== 'empty' && !s.isParticle;
      });
      if (!hasAccent) sentEl.classList.add('no-accent');
      sentEl.innerHTML = makeColoredSentence(sentSeqs[0]);
    }
  }

  // Definition → bilingual + monolingual
  var defs = parseDefinitions(defHtml);
  if (defs.bilingual) {
    defEl.innerHTML = defs.bilingual;
  } else {
    defEl.style.display = 'none';
  }
  if (defs.monolingual) {
    jpDefEl.innerHTML = defs.monolingual;
  } else {
    jpDefSection.style.display = 'none';
  }
}
_renderBack();
})();
</script>

<script>
(function() {
  var HANDLER_KEY = '__jpDefHandler';
  function handler(ev) {
    if (ev.code === 'KeyG') {
      var cb = document.getElementById('jp-toggle');
      if (cb) {
        ev.preventDefault();
        ev.stopPropagation();
        cb.checked = !cb.checked;
      }
    }
  }
  if (window[HANDLER_KEY]) {
    window.removeEventListener('keydown', window[HANDLER_KEY], true);
  }
  window[HANDLER_KEY] = handler;
  window.addEventListener('keydown', handler, { capture: true });
})();
</script>
